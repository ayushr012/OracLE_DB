ORACLE BUILT-IN FUNCTIONS :
---------------------------

  -> Oracle pre-defined functions are called as Built-in functions

  -> Basically functions are two types

          i. PRE-DEFINED Functions

		-> these functions are supported by SQL & PL/SQL 

         ii. USER-DEFINED

                -> only PL/SQL supports

PRE-DEFINED Functions:
----------------------

   -> Oracle pre-defined functions are 4 types

         I. COLUMN LEVEL FUNCTIONS

        II. GROUP FUNCTIONS

       III. CONVERSION FUNCTIONS

        IV. GENERAL FUNCTIONS

 
** In oracle db all functions are executed by using SELECT statement

I. COLUMN LEVEL FUNCTIONS :
---------------------------

  -> these functions are executed on each and every column values

  -> Column level functions are classified into 3 types

         i. NUMBER functions

        ii. CHARACTER functions

       iii. DATE Functions

i. NUMBER FUNCTIONS :
---------------------

  -> these functions are supports NUMARIC values

ABS() :
-------

  -> this function converts -ve value to +ve value

ex:-

  SELECT ABS(-100) from EMP;

SQL> SELECT ABS(-100) from DEPT;

ABS(-100)
---------
      100
      100
      100
      100

SQL> SELECT * FROM DEPT;

DEPTNO DNAME          LOC
------ -------------- -------------
    10 ACCOUNTING     NEW YORK
    20 RESEARCH       DALLAS
    30 SALES          CHICAGO
    40 OPERATIONS     BOSTON

SQL> SELECT ABS(-100) from DUAL;

ABS(-100)
---------
      100

NOTE: DUAL is one of the oracle pre-defined table and it contains only one record. so, function is exeucting       only one time.

POWER() :
---------
  
  -> This function returns power value

ex:-  

SQL> select power(2,3) from dual;

POWER(2,3)
----------
         8   

MOD() :
-------

  -> this function returns remainder

ex:- 

SQL> select mod(10,2) from dual;

MOD(10,2)
---------
        0

SQL> select mod(13,2) from dual;

MOD(13,2)
---------
        1

-- write a query to display who are getting ODD salaries

SQL> select * from emp where mod( sal, 2) !=0;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7566 JONES      MANAGER     7839 02-APR-81   3175            20

SQRT() :
--------

 -> it returns sqrt value

ex:-

SQL>   select sqrt( 25) from dual;

SQRT(25)
--------
       5

SQL>   select sqrt( -625 ) from dual;
  select sqrt( -625 ) from dual
               *
ERROR at line 1:
ORA-01428: argument '-625' is out of range

SIGN() :
--------

  -- this function returns if input value +ve then 1
                                          -ve then -1
                                          zero then 0

ex:-

 select sign(1000) from dual;

o/p: 1

 select sign(-1000) from dual;

o/p: -1

 select sign(0) from dual;

o/p: 0

SIN() :
-------

  -> It returns sin value

      select sin(90) from dual;
COS() :
-------

  -> It returns cos value

      select cos(90) from dual;

TAN() :
-------

  -> It returns tan value

      select tan(90) from dual;

round() :
---------

  -> this function used to rounded to nearest value

Ex:-

  select round(15.68) from dual;   -- 6 >=5

o/p: 16

note: by default fractional part rounded


Ex:-

  select round(15.48) from dual;   -- 4 >=5

o/p: 15

Ex:-

  select round(15.68,1) from dual;   -- 8 >=5
  
o/p: 15.7

Ex:-

  select round(15.64587,2) from dual;   -- 5 >=5
  
o/p:    15.65

-- waq to display each employee Daily Wages

SQL>     select empno, ename, round(sal/30), deptno from emp;

 EMPNO ENAME      ROUND(SAL/30) DEPTNO
------ ---------- ------------- ------
  7369 SMITH                 33     20
  7499 ALLEN                 60     30
  7521 WARD                  48     30
  7566 JONES                106     20
  7654 MARTIN                48     30
  7698 BLAKE                102     30
  7782 CLARK                 88     10
  7788 SCOTT                107     20

-- waq to display each employee experience in years

SQL> select empno, ename, sal, round( (sysdate-hiredate)/365 ), deptno from emp;

 EMPNO ENAME         SAL ROUND((SYSDATE-HIREDATE)/365) DEPTNO
------ ---------- ------ ----------------------------- ------
  7369 SMITH        1000                            41     20
  7499 ALLEN        1800                            41     30
  7521 WARD         1450                            41     30
  7566 JONES        3175                            41     20
  7654 MARTIN       1450                            40     30
  7698 BLAKE        3050                            41     30

TRUNC( ) :
----------

  -> this function is not rounded to nearest value

ex:-

    select trunc( 15.67 ) from dual;

o/p: 15

    select trunc( 15.8579,2 ) from dual;

o/p: 15.85


ii. Character Functions :
-------------------------

  -> these functions are suports CHARACTER values only

lower() :
---------

  -> it converts any formated string to lower case

SQL>       select lower('NARESH IT') from dual;

LOWER('NA
---------
naresh it

upper() :
---------

   -> this function converts any formated string to upper case

ex:-

SQL>    select upper('naresh it') from dual;

UPPER('NA
---------
NARESH IT

INITCAP() :
-----------

  -> this function returns initial capital letter

ex:-

SQL>   select initcap('rama krishna reddy') from dual;

INITCAP('RAMAKRISH
------------------
Rama Krishna Reddy


LENGTH() :
----------

  -> this function returns length of the string

SQL>    select length('naresh it') from dual;

LENGTH('NARESHIT')
------------------
                 9


-- waq to display which employee names contains 5 characters

SQL>   Select * from emp where length(ename)=5;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 17-DEC-80   1000            20
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1800    300     30
  7566 JONES      MANAGER     7839 02-APR-81   3175            20
  7698 BLAKE      MANAGER     7839 01-MAY-81   3050            30
  7782 CLARK      MANAGER     7839 09-JUN-81   2650            10

SQL> select ename, lower(ename), upper(ename), initcap(ename), length(ename) from emp;

ENAME      LOWER(ENAM UPPER(ENAM INITCAP(EN LENGTH(ENAME)
---------- ---------- ---------- ---------- -------------
SMITH      smith      SMITH      Smith                  5
ALLEN      allen      ALLEN      Allen                  5
WARD       ward       WARD       Ward                   4
JONES      jones      JONES      Jones                  5
MARTIN     martin     MARTIN     Martin                 6
BLAKE      blake      BLAKE      Blake                  5
CLARK      clark      CLARK      Clark                  5
SCOTT      scott      SCOTT      Scott                  5
KING       king       KING       King                   4
TURNER     turner     TURNER     Turner                 6

ASCII() :
---------

  -> it converts char value to equallent ascii code

ex:-

SQL>   select ascii('A') from dual;

ASCII('A')
----------
        65

SQL>   select ascii('a') from dual;

ASCII('A')
----------
        97

CHR() :
-------

  -> it converts ASCII code to equallent CHAR value

SQL>          select chr( 65 ) from dual;

C
-
A

SQL>          select chr( 97 ) from dual;

C
-
a

LPAD() :
--------

  -> this function returns leftside paddings( spaces )

SQL> select lpad( 'naresh',10) from dual;

LPAD('NARE
----------
    naresh

** to fill the spaces with special characters

SQL> select lpad( 'naresh',10, '*' ) from dual;

LPAD('NARE
----------
****naresh

RPAD() :
--------

  -> it returns right side paddings

SQL> select rpad( 'naresh',10) from dual;

RPAD('NARE
----------
naresh

SQL> select rpad( 'naresh',10,'*') from dual;

RPAD('NARE
----------
naresh****

-- waq to display following format output

       *** NARESH IT ***

SQL>  Select Rpad( Lpad( 'NARESH IT', 12,'*' ),15,'*' ) FROM DUAL;

RPAD(LPAD('NARE
---------------
***NARESH IT***

SQL>  Select Rpad( Lpad( ' NARESH IT ', 14,'*' ),17,'*' ) FROM DUAL;

RPAD(LPAD('NARESH
-----------------
*** NARESH IT *** 


CONCAT() :
----------

  -> this function used to concant two strings at a time

ex:-

  Select concat( 'naresh','it') from dual;

CONCAT('
--------
nareshit

nested functions :
------------------

SQL>  Select concat( concat( 'naresh',' it'), ',Hyderabad') from dual;

CONCAT(CONCAT('NAR
------------------
naresh it,Hyderabad

=> to concant muliple strings continuously then ORACLE provided || ( concatination operator ).

=> by using this operator we can multiple strings continuously...

Ex:-

SQL>   select 'Mr.' || 'Siva '||'Rama '|| 'Krishna ' || 'Raju' from dual;

'MR.'||'SIVA'||'RAMA'||'K
-------------------------
Mr.Siva Rama Krishna Raju

-- waq to display following format outputs

        i. mr.king is working as a president

       ii. mr.king is working as a president and getting annual salary rs.60000/-

ex:-

SQL> select 'Mr.'|| Ename || ' is working as a ' || Job from Emp;

'MR.'||ENAME||'ISWORKINGASA'||JOB
---------------------------------------
Mr.SMITH is working as a CLERK
Mr.ALLEN is working as a SALESMAN
Mr.WARD is working as a SALESMAN
Mr.JONES is working as a MANAGER
Mr.MARTIN is working as a SALESMAN
Mr.BLAKE is working as a MANAGER

SQL> select 'Mr.'|| Ename || ' is working as a ' || Job ||' and getting annual salary Rs.'||
           							( sal * 12 )  from Emp;
ANNUAL_SAL
----------------------------------------------------------------------------------------------------
Mr.SMITH is working as a CLERK and getting annual salary Rs.9600
Mr.ALLEN is working as a SALESMAN and getting annual salary Rs.19200
Mr.WARD is working as a SALESMAN and getting annual salary Rs.15000
Mr.JONES is working as a MANAGER and getting annual salary Rs.35700
Mr.MARTIN is working as a SALESMAN and getting annual salary Rs.15000
Mr.BLAKE is working as a MANAGER and getting annual salary Rs.34200
Mr.CLARK is working as a MANAGER and getting annual salary Rs.29400

LTRIM() :
---------

  -> this function used to trim leftside matching specified characters

SQL> select ltrim( 'UNION BANK OF INDIA', 'UNION' ) from dual;

LTRIM('UNIONBA
--------------
 BANK OF INDIA

RTRIM() :
---------

  -> This function used to trim right side specified matching characters

ex:-

SQL>   Select Rtrim('ramaaaaaaaaaa','a') from dual;

RTR
---
ram

TRIM() :
--------

  -> Used to deletes both sides specified matching characters

ex:-

SQL> select trim( 'a' from 'aaaaaaaaaramaaaaaaaaa') from dual;

TRI
---
ram


-- write query to display middle name from given name


input : 'ramesh sachin tendulkar'

output: sachin


 select trim( rtrim( ltrim('ramesh sachin tendulkar', 'ramesh' ) , 'tendulkar' )) from dual;

o/p: sachin

 
note: by default all trim functions Spaces

REPLACE() :
-----------

  -> This function replaced word by word

ex:

SQL> select replace( 'axis bank','axis', 'icici') from dual;

REPLACE('A
----------
icici bank

TRANSLATE() :
-------------

  -> this function used to translats char by char 

ex:-

SQL>  select translate( 'deepak', 'abcedfpk','*&^$@#+=') from dual;

TRANSL
------
@$$+*=

SUBSTR() :
----------

  -> this function used to displays substring from given string

ex:-

   select substr( 'rama krisha', 6 ) from dual;

6 -> substring displays from 6th position onwards 

o/p: krishna

ex:-

  select substr( 'rama krishna', 6, 4 ) from dual;

6 -> substring displays from 6th position onwards

4 -> no.of occurances

o/p: kris


ex:-

  select substr( 'rama krishna', -7 ) from dual;

-7 -> substring displays from 7th position onwards...
 
    ( position is counting from right -> left and substring displays left -> right by default)

o/p: krishna

ex:-

  select substr( 'rama krishna', -7, 4 ) from dual;

-7 -> substring displays from 7th position onwards...
 
    ( position is counting from right -> left and substring displays left -> right by default)

o/p: kris 

-- write a query to generate user ids automatically by using EMPNO & ENAME

SQL> select substr(ename, 1,3 ) || substr( empno, 1,3) || '@gmail.com' from emp;

SUBSTR(ENAME,1,3)||SUBSTR(EMPNO,1,
----------------------------------
SMI736@gmail.com
ALL749@gmail.com
WAR752@gmail.com
JON756@gmail.com
MAR765@gmail.com
BLA769@gmail.com

-- waq to display which employee names starting and ending characters are same

SQL> SELECT ENAME FROM EMP WHERE SUBSTR(ENAME,1,1) = SUBSTR( ENAME, -1, 1) ;

ENAME
----------
HEMANTH
ARCHANA

INSTR() :
---------

  -> This function returns searching string position

Ex:-

   Select instr( 'ORACLE CORPORATION', 'OR', 3, 2 ) FROM DUAL;

'OR'  -> searching string

3  -> searching starting from 3rd char. onwards

2  -> no.of times to be search

o/p: 12

note: position is counting from 1st char. onwards by default

Ex2:-

   Select instr( 'ORACLE CORPORATION', 'OR', 3, 1 ) FROM DUAL;

o/p: 9


Ex3:-

   Select instr( 'ORACLE CORPORATION', 'OR', 3, 3 ) FROM DUAL;

o/p: 0

Ex4:-

   Select instr( 'ORACLE CORPORATION', 'OR', -1, 1 ) FROM DUAL;

'OR'  -> searching string

-1   -> searching starting from 1st char. onwards from RIGHT -> LEFT

1  ->  1 time to be search

** searched string position is counting from LEFT -> RIGHT from 1st char. onwards that is fixed

o/p: 12


-- waq to display which employee names 'A' char. contains mininum two times

SQL> select ename from emp where instr(ename, 'A',1, 2 )>0;

ENAME
----------
ADAMS
ARCHANA

-- waq to which employee names not having 'A' CHAR

SQL> select ename from emp where instr(ename, 'A',1, 1 )=0;

ENAME
----------
JONES
SCOTT
KING
TURNER
MILLER

Example:
--------

  -- write a to display street name and city names separetely

table creation:
---------------

create table emp_db( empno number(4), address varchar(30) );

insert into emp_db values ( 1001, 'ameerpet hyderabad');
insert into emp_db values ( 1002, 'srnagar hyderabad');
insert into emp_db values ( 1003, 'panjangutta secunderabad');
commit;


-- waq to display only STREET NAMES

SQL> select substr( address, 1, instr( address, ' ', 1, 1 )-1    ) as street from emp_db;

street
----------------
ameerpet
srnagar
panjangutta
 

-- waq to display city names

SQL> select substr( address, instr( address, ' ', -1, 1 )+1   ) as city from emp_db;

city
---------------------
hyderabad
hyderabad
secunderabad


Exercise :
----------

-- write a query to display only user names


-- write a query to display only domain names


king@gmail.com
sottt@rediffmail.com
krishna@yahoo.co.in

iii. DATE FUNCTIONS :
---------------------

  -> these functions are supports date values

SYSDATE :
---------

  -> it is one of the oracle pre-defined column

  -> it display current server date and time

ex:-

   Select sysdate from dual;


SYSDATE
---------
06-JAN-22


i. ADD_MONTHS() :
-----------------

  -> this function used to add months to given date

  -> It accepts + or -

ex:-

SQL> select add_months( sysdate, 2 ) from dual;

ADD_MONTH
---------
06-MAR-22


SQL> select add_months( sysdate, -2 ) from dual;

ADD_MONTH
---------
06-NOV-21


ii. MONTHS_BETWEEN() :
----------------------  

   -> this function returns months between two given dates

Ex:-

 select months_between( sysdate, '10-jan-21') from dual;

SQL>  select months_between( sysdate, '10-jan-21') from dual;

MONTHS_BETWEEN(SYSDATE,'10-JAN-21')
-----------------------------------
                             11.899

iii. NEXT_DAY() :
-----------------

  -> It returns comming week of the Date

Ex:-

SQL>    Select next_day( sysdate, 'sat') from dual;

NEXT_DAY(
---------
08-JAN-22

SQL>    Select next_day( sysdate, 7 ) from dual;

NEXT_DAY(
---------
08-JAN-22

note: by defualt oracle takes...

             sunday - 1
             monday - 2
             .
             .
             saturday - 7

iv. LAST_DAY() :
----------------

  -> This function returns last date of the month

SQL> select last_day(sysdate) from dual;

LAST_DAY(
---------
31-JAN-22


Examples :
----------

i. write a query to display next month first date

          select last_day(sysdate)+1 from dual;

o/p:

LAST_DAY(
---------
01-FEB-22

ii. write a query to display current month first date

iii. write a query to display each emplyee experience

SQL> select empno, months_between( sysdate, hiredate )/12 as Experience from emp;

 EMPNO EXPERIENCE
------ ----------
  7369     41.056
  7499     40.881
  7521     40.876
  7566     40.763
  7654     40.277
  7698     40.682
  7782     40.578
  7788     39.078
  7839     40.139
  7844      40.33
  7876     38.986
  7900     40.094
  7902     40.094
  7934     39.957

14 rows selected.

iv. write a query to display current month 2nd and 4th saturday dates

SQL> 	
2nd_sat
---------
08-JAN-22

step by step :
--------------
SQL> select sysdate from dual;

SYSDATE
---------
24-JAN-22

SQL> select last_day(sysdate) from dual;

LAST_DAY(
---------
31-JAN-22

SQL> select add_months( last_day(sysdate), -1 ) from dual;

ADD_MONTH
---------
31-DEC-21

SQL> select add_months( last_day(sysdate), -1 )+7 from dual;

ADD_MONTH
---------
07-JAN-22

SQL> select next_day( add_months( last_day(sysdate), -1 )+7 , 'sat' ) from dual;

NEXT_DAY(
---------
08-JAN-22


** 4th saturday :
-----------------

SQL> select next_day( add_months( last_day(sysdate), -1 )+21 , 'sat' ) from dual;

NEXT_DAY(
---------
22-JAN-22

II. GROUP FUNCTIONS :
---------------------

  -> These functions can compare Multiple values and returns single value output

  -> Group functions are also called as AGGREGATE / MULTI-ROW FUNCTIONS

MIN() :
-------

  -> this function returns minimum value

       select min(sal) from emp;

MAX() :
-------

  -> this function returns maximum value

       select max(sal) from emp ;

SUM() :
-------

  -> this function returns total sum of salaries

SQL> select sum(sal) from emp;

SUM(SAL)
--------
   31325

AVG( ) :
--------

   -> this function returns avg. value

       select avg(sal) from emp;
COUNT() :
---------

  -> This function returns NO.OF VALUES / RECORDS from the table

 ex:  select count(empno) from emp;

    o/p: 13

      select count(comm) from emp;
 
    o/p: 4

note: to pass argument as COLUMN NAME then Count function IGNORES NULLs.  To display exact no.of records

        select count(*) from emp;

  o/p: 13

       
SQL> select count(1) from emp;

COUNT(1)
--------
      13

SQL> select count(2) from emp;

COUNT(2)
--------
      13

VARIANCE() :
------------

SQL>    select variance(sal) from emp;

VARIANCE(SAL)
-------------
   1801351.92


STDDEV( ) :
-----------
   
   -> sqrt of variance is called as stddev

SQL> select stddev(sal) from emp;

STDDEV(SAL)
-----------
 1342.14452

Other examples :
----------------

-- what is the output of following queries
 
select max(100,200) from emp;

  o/p: error, invalid no.of arguments

note: group functions accepts only 1 argument


select sum(ename) from emp;

  o/p: error, invalid datatype

note: sum & avg functions are Numaric functions

-- waq to display senior employee date of joining

SQL> select min(hiredate) from emp;

MIN(HIRED
---------
17-DEC-80

-- waq to display latest employee date of joining

SQL> select max(hiredate) from emp;

MAX(HIRED
---------
12-JAN-83

III. CONVERSION FUNCTIONS :
---------------------------

  -> these function can convert one datatype to another datatype temporarily

  -> Oracle supports three types of conversion functions

            i. to_char()

           ii. to_date()

          iii. to_number()

i. to_char() :
--------------

  -> this function used to convert DATE / NUMBER values into CHAR. format temporarily

  					or

  -> this function used to convert ORACLE pre-defined date into User Defined Data Format

       '07-JAN-22'   ->      TO_CHAR()    ->     07/01/22, 7th jan, 2022, etc.,

syn:- 

  To_char( DATE / NUMBER, 'fmt')

Ex:-

SQL> select sysdate from dual;

SYSDATE
---------
07-JAN-22

-- waq to display day of the week

'd'  -> it returns day of the week


select to_char(sysdate, 'd' ) from dual;    o/: 6

'dd'  -> returns day of the month   o/p: 07

select to_char(sysdate, 'dd' ) from dual;

'ddd'  -> returns date of the month   o/p: 007

select to_char(sysdate, 'ddd' ) from dual;

'dy'   -> returns day of the year   o/p: 007

select to_char(sysdate, 'dy' ) from dual;

'dy'  -> it returns form of the day   o/p: fri

'day'  -> it returns full form of the day   o/p: friday

select to_char(sysdate, 'day' ) from dual;  o/p: friday

'w'  -> week of the month  o/p: 1

select to_char(sysdate, 'w' ) from dual;

'ww'  -> week of the year

SQL> select to_char(sysdate, 'ww' ) from dual;

TO
--
01

'mm'  -> month in numaric format

SQL> select to_char(sysdate, 'mm' ) from dual;   o/p: 01

'mon' -> returns first three chars. of the month

SQL> select to_char(sysdate, 'mon' ) from dual;   o/p: jan

'month' -> returns full form of the month

SQL> select to_char(sysdate, 'month' ) from dual;   o/p: january

'y'  -> returns last rightmost digit  o/p: 2

'yy' -> last two digits of the year  o/p: 22

'yyy'  -> last three digits of the year  o/p: 022

'yyyy' -> returns year in number format  o/p: 2022

select to_char( sysdate, 'y-yy-yyy-yyyy') from dual;

o/p: 

TO_CHAR(SYSDA
-------------
2-22-022-2022

'year'  -> returns year in char. format

SQL> select to_char( sysdate, 'year') from dual;

TO_CHAR(SYSDATE,'YEAR')
------------------------------------------
twenty twenty-two

'q' -> returns quarter of the year

SQL> select to_char( sysdate, 'q') from dual;

T
-
1

'cc'  -> returns current century

SQL> select to_char( sysdate, 'cc') from dual;

TO
--
21

'ddth'  -> returns day of the month in the following formats
 
            ex: 01st, 02nd, 03rd, 04th, etc.,

SQL> select to_char( sysdate, 'ddth') from dual;

TO_C
----
08th

'DDsp'  -> returns day of the month in spelled format

ex:   select to_char(sysdate, 'ddsp') from dual;

SQL> select to_char(sysdate, 'ddsp') from dual;

TO_CHAR(SYSD
------------
eight

'J'  -> returns date in JULIAN format

     -> returns no.of days from oralce starting date to till date

     -> Oracle starting date is '01-jan-4712B.C' to '31-DEC-9999A.D'

Ex:-

SQL>    Select to_char( sysdate, 'j') from dual;

TO_CHAR
-------
2459588

Examples :
----------

  -- waq to display system date in the following formats

        i. 08/01/2022

SQL> select TO_char( sysdate, 'dd/mm/yyyy') from dual;

TO_CHAR(SY
----------
08/01/2022

       ii. 01/08/22

SQL> select TO_char( sysdate, 'mm/dd/yy') from dual;

TO_CHAR(
--------
01/08/22


      iii. 01st jan, 2022

SQL> select TO_char( sysdate, 'ddth mon, yyyy.') from dual;

TO_CHAR(SYSDATE,'DDTHMON
------------------------
08th jan, 2022.

-- waq to display date along with time

SQL> select to_char( sysdate, 'dd/mm/yy hh:mi:ss a.m.') from dual;

TO_CHAR(SYSDATE,'DD/MM
----------------------
08/01/22 08:28:42 p.m.

SQL> select to_char( sysdate, 'dd/mm/yy hh24:mi:ss a.m.') from dual;

TO_CHAR(SYSDATE,'DD/MM
----------------------
08/01/22 20:28:50 p.m.

-- to apply to_char on HIREDATE column

SQL> select empno, ename, sal, to_char(hiredate,'dd/mm/yy'), deptno from emp;

 EMPNO ENAME         SAL TO_CHAR( DEPTNO
------ ---------- ------ -------- ------
  7369 SMITH        1000 17/12/80     20
  7499 ALLEN        1800 20/02/81     30
  7521 WARD         1450 22/02/81     30
  7566 JONES        3175 02/04/81     20
  7654 MARTIN       1450 28/09/81     30

-- waq to display who are joined on 81 year

SQL> select * from emp where to_char(hiredate, 'yy')=81;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1800    300     30
  7521 WARD       SALESMAN    7698 22-FEB-81   1450    500     30
  7566 JONES      MANAGER     7839 02-APR-81   3175            20
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1450   1400     30
  7698 BLAKE      MANAGER     7839 01-MAY-81   3050            30
  7782 CLARK      MANAGER     7839 09-JUN-81   2650            10

-- waq to display who are joined on NOVEMBER MONTH

SQL> select * from emp where to_char(hiredate, 'MM')=11;


-- waq to display who are joined on last month

 SQL> select * from emp where  to_char( hiredate, 'mm-yyyy') =  to_char(add_months(sysdate, -1), 'mm-yyyy');

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7788 SCOTT      ANALYST     7566 13-DEC-21   3200            20
  7902 FORD       ANALYST     7566 21-DEC-21   3200            20

-- waq to display who are joined current month till date

SQL> select * from emp where to_char(hiredate, 'mm-yyyy') = to_char(sysdate, 'mm-yyyy');

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 01-JAN-22   1000            20
  7521 WARD       SALESMAN    7698 07-JAN-22   1450    500     30

How to Convert to NUMBER to CHAR temporarily :
---------------------------------------------

ex:-

  -- write a query to display employee salary in the following format

        5,000.00
        3,600.00


SQL> SELECT EMPNO, ENAME, SAL, TO_CHAR( SAL, '9,99,999.99') FROM EMP;

					OR


SQL> SELECT EMPNO, ENAME, SAL, TO_CHAR( SAL, '9G99G999D99') FROM EMP;

 EMPNO ENAME         SAL TO_CHAR(SAL,
------ ---------- ------ ------------
  7369 SMITH        1000     1,000.00
  7499 ALLEN        1800     1,800.00
  7521 WARD         1450     1,450.00
  7566 JONES        3175     3,175.00
  7654 MARTIN       1450     1,450.00
  7698 BLAKE        3050     3,050.00
  7782 CLARK        2650     2,650.00
  7788 SCOTT        3200     3,200.00
  7839 KING         5200     5,200.00
  7844 TURNER       1700     1,700.00
  7876 ADAMS        1300     1,300.00
  7900 JAMES        1150     1,150.00
  7902 FORD         3200     3,200.00
  7934 MILLER       1500     1,500.00

14 rows selected.

'G'  -> group separator ( , )

'D' -> decimal ( . )

NUMBER FORMATS :
----------------

'c'  -> local currancy name

SQL> SELECT EMPNO, ENAME, SAL, TO_CHAR( SAL, 'C9G99G999D99') FROM EMP;

 EMPNO ENAME         SAL TO_CHAR(SAL,'C9G99G
------ ---------- ------ -------------------
  7369 SMITH        1000         USD1,000.00
  7499 ALLEN        1800         USD1,800.00
  7521 WARD         1450         USD1,450.00
  7566 JONES        3175         USD3,175.00
  7654 MARTIN       1450         USD1,450.00
  7698 BLAKE        3050         USD3,050.00
  7782 CLARK        2650         USD2,650.00


'l'  -> returns local currancy symbol


SQL> SELECT EMPNO, ENAME, SAL, TO_CHAR( SAL, 'l9G99G999D99') FROM EMP;

 EMPNO ENAME         SAL TO_CHAR(SAL,'L9G99G999
------ ---------- ------ ----------------------
  7369 SMITH        1000              $1,000.00
  7499 ALLEN        1800              $1,800.00
  7521 WARD         1450              $1,450.00
  7566 JONES        3175              $3,175.00
  7654 MARTIN       1450              $1,450.00
  7698 BLAKE        3050              $3,050.00

's'  -> returns sign symbol

SQL> SELECT EMPNO, ENAME, SAL, TO_CHAR( SAL, 's9G99G999D99') FROM EMP;

 EMPNO ENAME         SAL TO_CHAR(SAL,
------ ---------- ------ ------------
  7369 SMITH        1000    +1,000.00
  7499 ALLEN        1800    +1,800.00
  7521 WARD         1450    +1,450.00
  7566 JONES        3175    +3,175.00
  7654 MARTIN       1450    +1,450.00
  7698 BLAKE        3050    +3,050.00
  7782 CLARK        2650    +2,650.00

** to change currancy from one country to another country temporarily then ... :
--------------------------------------------------------------------------------

ALTER SESSION SET NLS_TERRITORY='INDIA';

SQL> SELECT EMPNO, ENAME, SAL, TO_CHAR( SAL, 'C9G99G999D99') FROM EMP;

 EMPNO ENAME         SAL TO_CHAR(SAL,'C9G99G
------ ---------- ------ -------------------
  7369 SMITH        1000         INR1,000.00
  7499 ALLEN        1800         INR1,800.00
  7521 WARD         1450         INR1,450.00
  7566 JONES        3175         INR3,175.00
  7654 MARTIN       1450         INR1,450.00

SQL> SELECT EMPNO, ENAME, SAL, TO_CHAR( SAL, 'l9G99G999D99') FROM EMP;

 EMPNO ENAME         SAL TO_CHAR(SAL,'L9G99G999
------ ---------- ------ ----------------------
  7369 SMITH        1000             Rs1,000.00
  7499 ALLEN        1800             Rs1,800.00
  7521 WARD         1450             Rs1,450.00
  7566 JONES        3175             Rs3,175.00
  7654 MARTIN       1450             Rs1,450.00
  7698 BLAKE        3050             Rs3,050.00

ii. TO_DATE() :
---------------

  -> This function converts User defined date format into Oracle pre-defined date format

           10/01/22   ->   to_date()   ->   '10-jan-22'

Ex:-  

   -- to convert 10/01/22  into 10-jan-22

      select to_date( '10/01/22', 'dd/mm/yy' ) from dual;

TO_DATE('
---------
10-JAN-22


  -- to convert 01/23/21  to  23-jan-21

SQL> select to_date( '01/23/21', 'mm/dd/yy') from dual;

TO_DATE('
---------
23-JAN-21

-- write a query to display date of independancy day

         '15/08/1947'   

SQL> select to_char( to_date('15/08/1947', 'dd/mm/yyyy'), 'day')  from dual;

TO_CHAR(T
---------
friday

iii. to_number() :
------------------

  -> this function used to convert character number into number format

      select  1,234.56 + 786.89 from dual;


     select to_number('1,234.56', '9,999.99') + 786.89 from dual;
 
SQL> select to_number('1,234.56', '9,999.99') + 786.89 from dual;

TO_NUMBER('1,234.56','9,999.99')+786.89
---------------------------------------
                                 2021.5

    
IV. GENERAL FUNCTIONS :
-----------------------

   -> these functions are applicable for any datatypes

i.GREATEST():
-------------

  -> this function returns greatest value from given list of values

        select greatest(10,20,30,40) from dual;

o/p: 40

max() :
-------

  -> it is a single argument function

greatest() :
------------

  -> it is multi-argument function

Least() :
---------

   -> this function retuns least vlaue from given list of values

ex:-

  SQL> select least( 'd','cd', 'bcd', 'abcd' ) from dual;

LEAS
----
abcd


UID :
------

  -> returns presently connected uid

SQL>        select uid from dual;

   UID
------
    49

USER :
------

  -> returns currently connect user name

SQL> select user from dual;

USER
------------------------------
ORA8PM

NVL( ) :
--------

  -> this function used to perform arithmetic operations by using NULLs

  -> generally to evaluate any expression using NULLs output returns NULL, to overcome this to use NVL function

  -> this accepts two arguments

syn:-

  NVL( arg1, arg2 )

        -> if arg1 is null then it executes arg2 otherwise arg1 output

ex:-

SQL>      select nvl(null,200), nvl( 100, 200 ) from dual;

NVL(NULL,200) NVL(100,200)
------------- ------------
          200          100

-- waq to find each employee net salary

     netsal = sal + comm

SQL>       select empno, ename, sal, nvl(comm,0),  sal + nvl(comm,0),  deptno from emp;

 EMPNO ENAME         SAL NVL(COMM,0) SAL+NVL(COMM,0) DEPTNO
------ ---------- ------ ----------- --------------- ------
  7369 SMITH        1000           0            1000     20
  7499 ALLEN        1800         300            2100     30
  7521 WARD         1450         500            1950     30
  7566 JONES        3175           0            3175     20
  7654 MARTIN       1450        1400            2850     30
  7698 BLAKE        3050           0            3050     30
  7782 CLARK        2650           0            2650     10


DISTINCT() :
------------

  -> this function used to eliminates DUPLICATE values

SQL>        select distinct(deptno) from emp;

DEPTNO
------
    30
    20
    10

SQL> select distinct(job) from emp;

JOB
---------
CLERK
SALESMAN
PRESIDENT
MANAGER
ANALYST

SOUNDEX() :
-----------

  -> This function used to compares the data based on given pronounsation

-- waq to display smith's employee data

SQL> select * from emp where SOUNDEX(ename)=SOUNDEX('ssssssssssssmit');

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 01-JAN-22   1000            20 

SQL> select * from emp where SOUNDEX(ename)=SOUNDEX('alloneeeee');

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1800    300     30

Compelete SELECT statement syntax:
----------------------------------

SELECT * / COLUMN_LIST FROM <TABLE_NAME>
			      [	WHERE <CONDITION>/
				GROUP BY CLAUSE/
				HAVING <CONDITION>/
				ORDER BY CLAUSE
                              ]

Order of execution of SELECT statement is :
-------------------------------------------

FROM
WHERE 
GROUP BY
HAVING
SELECT 
ORDER BY

Select statement rules :
------------------------

  -> in SELECT statement all columns should be return similar no.of values/records

       select empno, max(sal) from emp;          => invalid
              ------ --------
                14      1

       select empno, sal from emp;       => valid
              -----  ----
                14     14

       select min(sal), max(sal) from emp;           => valid
              --------  -------
                 1         1

  -> in SELECT you should be declare all are Ordinary columns or all are GROUP functions

GROUP BY :
----------

   -> Used to group the rows on Specified columns

   -> whenever an ordinary column retrieved along with group function then all ordinary columns must be placed
      after group by clause

ex:-

  -- waq to display dept.wise sum of salaries

SQL> SELECT  DEPTNO, SUM(SAL) FROM EMP GROUP BY DEPTNO;

DEPTNO SUM(SAL)
------ --------
    30    10600
    20    11875
    10     9350

 -- Waq to display dept.wise min. and maximum salaries

SQL> select deptno, min(sal), max(sal) from emp group by deptno;

DEPTNO MIN(SAL) MAX(SAL)
------ -------- --------
    30     1150     3050
    20     1000     3200
    10     1500     5200

-- waq to display each job min and maximum salaries

select job, min(sal), max(sal) from emp group by job;

-- waq to display each dept. howmany employees are working

select deptno, count(deptno) from emp group by deptno;


SQL> select deptno, count(deptno) from emp group by deptno;

DEPTNO COUNT(DEPTNO)
------ -------------
    30             6
    20             5
    10             3

-- waq to display dept.wise with jobwise no.of employees

o/p:
10 clerk 1
20 clerk 2
30 clerk 1
10 manager 1
.
.


select deptno, job, count(*) from emp group by deptno, job order by deptno, job;

SQL> select deptno, job, count(*) from emp group by deptno, job order by deptno, job;

DEPTNO JOB       COUNT(*)
------ --------- --------
    10 CLERK            1
    10 MANAGER          1
    10 PRESIDENT        1
    20 ANALYST          2
    20 CLERK            2
    20 MANAGER          1
    30 CLERK            1
    30 MANAGER          1
    30 SALESMAN         4

9 rows selected.

-- waq to display in each year howmany employees are joined

SQL> select to_char(hiredate,'yyyy') as year, count(*) from emp
                                         group by to_char(hiredate,'yyyy')
                                                      order by year;

YEAR COUNT(*)
---- --------
1981        8
1982        1
1983        1
2021        2
2022        2

HAVING clause :
---------------

  -> this clause is used to check the given condition

  -> HAVING clause is valid after group by clause

  -> Having clause is used to GROUP COLUMN values / GROUP FUNCTION results

Ex:-

  -- waq to display in which depts. morethan 3 employees are working

SQL> select deptno, count(*) from emp group by deptno having count(*)>3;

DEPTNO COUNT(*)
------ --------
    30        6
    20        5

-- waq to display in which jobs, minimum salary > 2000

SQL>  select job, min(sal) from emp group by job having min(sal)>2000;

JOB       MIN(SAL)
--------- --------
PRESIDENT     5200
MANAGER       2650
ANALYST       3200


WHERE clause :
--------------

  -> used to check ordinary column values

  -> WHERE clause is valid before GROUP BY clause

ORDER BY Clause :
-----------------

  -> it displays information either ascending or decending order

  -> by default ORDER BY clause displays ASCENDING ORDER

  -> Only SELECT statement supports ORDER BY CLAUSE

  -> ORDER BY clause must be placed at the end of SELECT statement

  -> ORDER BY clause supports Alias

ex:-

  select * from emp order by deptno asc;
 
  select * from emp order by deptno;

  select * from emp order by deptno desc;

  select * from emp order by deptno, ename;

using alaise :
--------------

  select empno, ename, job, sal, nvl(comm,0), sal + nvl(comm,0) as total_sal, deptno from emp
                                              order by total_sal;
  
 EMPNO ENAME      JOB          SAL NVL(COMM,0) TOTAL_SAL DEPTNO
------ ---------- --------- ------ ----------- --------- ------
  7369 SMITH      CLERK       1000           0      1000     20
  7900 JAMES      CLERK       1150           0      1150     30
  7876 ADAMS      CLERK       1300           0      1300     20
  7934 MILLER     CLERK       1500           0      1500     10
  7844 TURNER     SALESMAN    1700           0      1700     30
  7521 WARD       SALESMAN    1450         500      1950     30
  7499 ALLEN      SALESMAN    1800         300      2100     30
  7782 CLARK      MANAGER     2650           0      2650     10
  7654 MARTIN     SALESMAN    1450        1400      2850     30
  7698 BLAKE      MANAGER     3050           0      3050     30
  7566 JONES      MANAGER     3175           0      3175     20
  7902 FORD       ANALYST     3200           0      3200     20
  7788 SCOTT      ANALYST     3200           0      3200     20
  7839 KING       PRESIDENT   5200           0      5200     10

14 rows selected.

-- what is output of following query ?

select * from emp order by 3;

note: it is valid, it takes 3 column display with order

SQL>   select * from emp order by 3;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7788 SCOTT      ANALYST     7566 13-DEC-21   3200            20
  7902 FORD       ANALYST     7566 21-DEC-21   3200            20
  7934 MILLER     CLERK       7782 23-JAN-82   1500            10
  7900 JAMES      CLERK       7698 03-DEC-81   1150            30
  7369 SMITH      CLERK       7902 01-JAN-22   1000            20
  7876 ADAMS      CLERK       7788 12-JAN-83   1300            20
  7698 BLAKE      MANAGER     7839 01-MAY-81   3050            30
  7566 JONES      MANAGER     7839 02-APR-81   3175            20
  7782 CLARK      MANAGER     7839 09-JUN-81   2650            10
  7839 KING       PRESIDENT        17-NOV-81   5200            10
  7844 TURNER     SALESMAN    7698 08-SEP-81   1700      0     30
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1450   1400     30
  7521 WARD       SALESMAN    7698 07-JAN-22   1450    500     30
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1800    300     30

14 rows selected. 


CONSTRAINTS :
-------------


  -> Constraint is a pre-defined rule, that rule is applied on db columns at the time of TABLE CREATION or           AFTER TABLE CREATION

  -> Constraints are activated whenever DML commands are performed

  -> Constraints are also activated when the tables are manipulated by other users or by other application
     software tools

  -> constraints used restrict user defined conditions and business rules

  -> All created constraint names are stored in USER_CONSTRAINTS ( system table )

TYPES OF CONSTRAINTS :
----------------------

   -> Oracle supportes 6 types constraints

I. NOT NULL constraint

II. UNIQUE Constraint

III. CHECK Constraint 

IV. DEFAULT Constraint

V. PRIMARY KEY Constraint

VI. FOREIGN KEY Constraint(REFERENCES)


  -> constraints are added table of columms there are 3 methods

i. column level

ii. table level

iii. alter level


i. column level :
-----------------

  -> constraints are added next to column name at the time of table creation is called as 
     column level constraints

syn:-

Create table <table_name>
( col1 datatype(size)
              [constraint <constraint_name>] <constraint_type>,
  col2 datatype(size)
              [constraint <constraint_name>] <constraint_type>,
  .
  .
);

ii. table level constraints :
-----------------------------

  -> constriants are added after declaring all columns at the time of table creation is called as
     table level constraints

syn:-

Create table <table_name>
( col1 datatype(size),
  col2 datatype(size),
  .
  .
  ,
  [Constraint <constraint_name>] <constraint_type>( col1 [, col2,...] )
);


iii. Alter level Constraints :
------------------------------

  -> After Table creation we can add constraints to db columns is called as ALTER LEVEL constraints

syn:-
 
ALTER TABLE <Table_Name> ADD/MODIFY [Constraint <constraint_name>] <constraint_type>( col1 [, col2,...] );


I. NOT NULL Constraint :
------------------------

  -> By default in oracle all columns are accepted NULLs to restrict NULLs then NOT NULL constraint supported

  -> this constraint doesn't accept NULLs

  -> NOT NULL constraint is supported in COLUMN LEVEL & ALTER LEVEL only

  -> In db columns if any column value is mandatory then to use NOT NULL constraint

  -> NOT NULL constraint allows DUPLICATES

Ex:-

   -- create a employee db table with employee id, employee name

Validations :
-------------

  -> Employee id column value is mandatory

Table creation:
---------------

create table employ
( eid number(4)
       constraint employ_eid_nn NOT NULL, 
  ename varchar2(10)
);

testing :
---------

Insert into employ values( 1001, 'king' );
Insert into employ values( 1002, 'scott' );
Insert into employ values( NULL, 'allen' );    => Error

SQL> select * from employ;

   EID ENAME
------ ----------
  1001 king
  1002 scott

II. UNIQUE Constraint :
------------------------

  -> This constraint is used to AVOIDS duplicate values

  -> UNIQUE constraint supported in 3 level

  -> maximum each and every table contains on key column on that key columns we can add UNIQUE constraint

  -> UNIQUE constraint accepts 'n' no.of NULLs

Ex:-

 -- create a employee table with employee id, employee name

validations:
------------

  -> Employee id should not be allow duplicates

Table creation:
---------------

create table employ
( Eid number(4)
        constraint employ_eid_un UNIQUE,
  Ename varchar(10)
);

testing :
---------

 Insert into Employ values ( 1001, 'king' );
 Insert into Employ values ( 1002, 'scott' );
 Insert into Employ values ( 1001, 'allen' );   => ERROR

SQL>  Insert into Employ values ( 1001, 'allen' );
 Insert into Employ values ( 1001, 'allen' )
*
ERROR at line 1:
ORA-00001: unique constraint (ORA8PM.EMPLOY_EID_UN) violated

SQL>  Insert into Employ values ( NULL, 'allen' );

1 row created.

SQL>  Insert into Employ values ( NULL, 'ward' );

1 row created.

SQL> select  * from employ;

   EID ENAME
------ ----------
  1001 king
  1002 scott
       allen
       ward


How to add TWO different constraints to single column :
-------------------------------------------------------

Ex:- 

  -- create a student table with student id and student name

validations:
------------

  -> student id is mandatory

  -> studnet id should not be allow duplicates

Table creation:
---------------

Create table student1233
( std_id number(4)
    constraint student_std_id_nn not null
    constraint studnet_std_id_un unique,
  std_name varchar2(10)
);

		or

Create table student
( std_id number(4)
    constraint student_std_id_nn_un not null unique,
  std_name varchar2(10)
);


SQL> insert into student values ( 1, 'aaa');

1 row created.

SQL> insert into student values ( 2, 'bbb');

1 row created.

SQL> insert into student values ( null, 'ccc');
insert into student values ( null, 'ccc')
                             *
ERROR at line 1:
ORA-01400: cannot insert NULL into ("ORA8PM"."STUDENT"."STD_ID")


SQL> insert into student values ( 2, 'ccc');
insert into student values ( 2, 'ccc')
*
ERROR at line 1:
ORA-00001: unique constraint (ORA8PM.STUDNET_STD_ID_UN) violated


SQL> select * from student;

STD_ID STD_NAME
------ ----------
     1 aaa
     2 bbb

III. CHECK Constraint :
-----------------------
  
   -> this constraint is used to check the given condition

   -> if given condition is TRUE then record inserted otherwise it returns error message

Ex:-

 -- create a employee table with emloyee id, employee name & salary

validations :
-------------

  -> Employee salary should be > rs.3000

Table creation:
---------------

Create table employ
( Empid Number(10),
  Ename varchar2(20),
  Sal Number(8,2)
       constraint employ_sal_chk CHECK ( Sal >=3000 )
);

testing :
---------

SQL>  Insert into employ values( 1001, 'king', 5000 );

1 row created.

SQL>  Insert into employ values( 1002, 'scott', 4000 );

1 row created.

SQL>  Insert into employ values( 1003, 'smith', 2000 );
 Insert into employ values( 1003, 'smith', 2000 )
*
ERROR at line 1:
ORA-02290: check constraint (ORA8PM.EMPLOY_SAL_CHK) violated


SQL> select * from employ;

 EMPID ENAME                   SAL
------ -------------------- ------
  1001 king                   5000
  1002 scott                  4000

Other examples :
----------------

Validations :
-------------

  -> status should be accepts either 'y' or 'n'

        status char(1) check ( status in ( 'y','n') )

  -> employee age should be >=18 years

        age number(6,2) check ( age >=18 )

   -> Minimum Tras. amount rs.1

        Tamount Number(8,2) check ( tamount >=1 )

  -> mail id should be end with .com or .co.in

        mail_id varchar2(20) check ( mail_id like '%.com' or mail_id like '%.co.in') 

  -> mail id should be contains '@' symbol

  -> trans. type accepts either 'd' or 'w'

  -> trans. amount should be multiples of 100s

  -> Mobileno no. should be accepts only 10 digits

IV. DEFAULT Constraint :
-----------------------

  -> this constraint is used to take specified default value

  -> if any column value is fixed on that column we can DEFAULT constraint

ex:-

  -- create a student db table with student id, student name , classs and fee

validations:
------------

  ->  student fee is rs.1000 fixed

Table creation:
---------------

Create table student
( std_id varchar(10),
  std_name varchar(20),
  class varchar(10),
  fee number(8,2) Default 1000
);

SQL> insert into student values ( 's1', 'king', 'xi' , default);

1 row created.

SQL> insert into student( std_id, std_name, class) values  ( 's2', 'scott', 'xi' );

1 row created.

SQL> select * from student;

STD_ID     STD_NAME             CLASS         FEE
---------- -------------------- ---------- ------
s1         king                 xi           1000
s2         scott                xi           1000

SQL> insert into student values ( 's1', 'king', 'xi' , 1500);

1 row created.

SQL> select * from student;

STD_ID     STD_NAME             CLASS         FEE
---------- -------------------- ---------- ------
s1         king                 xi           1000
s2         scott                xi           1000
s1         king                 xi           1500


Ex2:-

Validations:
------------

  -> Employee Date of Joining is system date

V. PRIMARY KEY Constraint( Unique + Not Null + Index ) : 
--------------------------------------------------------

 -> Primary Key is one the Oracle Integrity constraint

 -> It is a combination of UNIQUE, NOT NULL and INDEX

 -> Primary key constraint doesn't accept NULLs and Duplicates

 -> Once Primary key added to any column by default INDEX object is added, Index main functionality
    It improves the performance while retrieving or manipulating data

 -> This index is also called as IMPLICIT INDEX

 -> In Column Level method only ONE column supports PRIMARY KEY Constraint

 -> To add PRIMARY KEY constraint to morethan one column it is possible in TABLE LEVEL / ALTER LEVEL method

 -> If table contains only PRIMARY KEY constraints that table is called as PURE MASTER TABLE 

 -> If table contains Primary Keys and other constraints that table is called as MASTER TABLE / PARENT TABLE /
    INDEPENDENT TABLE

 -> Primary key constraint not supported if any column datatype contains LOB, BLOB, CLOB, RAW, LONG RAW,
    Varrarys, Nested tables, etc.,

Example :
---------

  -- Create a new db table with Dept id, Dept. name & location

Validations :
-------------

  -> Dept id is mandatory

  -> Dept. Id Should not be allow duplicates

Table creation:
---------------

Create table Dept_Mas
( Dept_id Number(2)
     Constraint Dept_mas_dept_id_pk PRIMARY KEY,
  Dept_Name Varchar2(10),
  Dept_Loc Varchar2(10)
);

Testing :
---------

  Insert Into Dept_mas values ( 10, 'Acc', 'Hyd' );
  Insert Into Dept_mas values ( 20, 'Res', 'Sec' );
  Insert Into Dept_mas values ( 30, 'Fin', 'Chennai' );
  Insert Into Dept_mas values ( 40, 'Admin', 'Banglore' );
  Insert Into Dept_mas values ( 40, 'Sales', 'Banglore' );   => Error
  Insert Into Dept_mas values ( NULL, 'Sales', 'Banglore' );   => Error

SQL> select * from dept_mas;

DEPT_ID DEPT_NAME  DEPT_LOC
------- ---------- ----------
     10 Acc        Hyd
     20 Res        Sec
     30 Fin        Chennai
     40 Admin      Banglore
    

EMPLOY -> Empid	Ename	Sal	Dept_id (FK) REFERENCES DEPT_MAS(DEPT_ID) 
        1001	king	5000	10
	1002	scott	3000	30
	1003	jones	3500	10    
	1004	smith	1500	NULL   
   
VI. FOREIGN KEY Constraint( REFERENCES ) :
------------------------------------------

  -> It is one of the ORACLE Referential Integrity Constraint

  -> Foreign key constraint is used to establish relationship between two tables of columns or
     Same of table of column

  -> To Add Foreign key constraint on any column REFERENCED Table( Dept_Mas ) Referenced column should be 
     contain PRIMARY KEY or UNIQUE constraint

  -> Foreign Key constraint supported in 3 LEVEL ( column, table and alter levels )

  -> Foeign key constraint accepts DUPLICATES & NULLs

  -> if Table contains only FOREIGN KEY constraint that table is called as PURE DETAILED TABLE

  -> if Table contains Foreign keys and other constraints that table is called as TRANSACTION TABLE /
     CHILD TABLE / DEPENDENT TABLE

  -> Foreign key constraint not supported in any contains UN-STRUCTURED DATATYPES

Example :
---------

  -- Create a employee table with employee id, employee name, salary & dept id

Validations :
-------------

  -> Recruiting employee dept id should be available in the organization

Table creation:
---------------

Create table Employ
( Empid Number(4),
  Ename Varchar2(10),
  Sal Number(8,2),
  Dept_Id Number(2)
	Constraint Employ_dept_id_fk REFERENCES Dept_Mas(Dept_id)
);

Testing :
---------

Insert into Employ Values ( 1001, 'king', 5000, 10 );
Insert into Employ Values ( 1002, 'jones', 4000, 30 );
Insert into Employ Values ( 1003, 'smith', 2500, 10 );
Insert into Employ Values ( 1004, 'allen', 800, 20 );
Insert into Employ Values ( 1005, 'ford', 1400, 10 );
Insert into Employ Values ( 1007, 'blake', 1300, null );      => accepted
Insert into Employ Values ( 1006, 'james', 3300, 20 );


SQL> select * from dept_mas;

DEPT_ID DEPT_NAME  DEPT_LOC
------- ---------- ----------
     10 Acc        Hyd
     20 Res        Sec
     30 Fin        Chennai
     40 Admin      Banglore
 
SQL> select * from employ;

 EMPID ENAME         SAL DEPT_ID
------ ---------- ------ -------
  1001 king         5000      10
  1002 jones        4000      30
  1003 smith        2500      10
  1004 allen         800      20
  1005 ford         1400      10
  1006 james        3300      20
  1007 blake        1300

7 rows selected.

SQL> Insert into Employ Values ( 1003, 'smith', 2500, 50 );
Insert into Employ Values ( 1003, 'smith', 2500, 50 )
*
ERROR at line 1:
ORA-02291: integrity constraint (ORA7PM.EMPLOY_DEPT_ID_FK) violated - parent key not found


Automation of Training Institute :
----------------------------------  

course_mas : course_id,  course_name, Duration

validations:

   -> course id is mandatory & should not be allow duplicates

   -> minimum course durations 30 days

Fee_mas : course_id, Fee

validations:
------------

  -> Inserting course id should be available in course master table

Trans : Tno, Student name, course_id,  date of joining, amount and remarks

validations:
------------

  -> Tno should be unique & mandatory

  -> student joining course should be available in the Institute
 

Table creation:
----------------

Create table course_mas
( course_id varchar(10)
	constraint course_mas_course_id_pk Primary Key,
  course_name varchar(20),
  Duration number(4) 
	constraint course_mas_duration_chk check ( duration >=30 )
);


Create table fee_mas
( course_id varchar(10)
    	   Constraint fee_mas_course_id_fk 
				REFERENCES Course_Mas( Course_id ),
  fee Number(8,2)
);


Create table trans
( tno number(4)
	constraint trans_tno_pk primary key,
  std_name varchar(20),
  course_id varchar(10)
	Constraint trans_course_id_fk 
			REFERENCES course_mas( Course_id ),
  doj date,
  amount number(8,2),
  remarks varchar(50)
);


** Insert data into above tables  				  

Other Example :
---------------

Dept : deptno(pk),  dname,  loc

Emp : empno(pk), ename, doj, sal, deptno(fk)

shift : shiftid(pk), shiftname

task: tid(pk), taskname

trans: tno(pk),  tdate,  empno(fk), deptno(fk),  tid(fk),  shiftid(fk),  status



item_mas : item_id(Pk)    item_name,   price
 I1
 I2
 I3
 .
 .
 I10


order :
ORD_ID  ord_date  item_id  qty  tamount
ord1	 -----     I20       2     80.


SELF FOREIGN KEY or SELF REFERENCE :
------------------------------------

  -> Foreign key constraint is REFERENCED with same table of PRIMARY KEY constraint is called as SELF REFERENCE

Example:
--------

  -- Create a employee table with employee id, employee name, manager id, salary & deptno

Validations:
------------

  -> Assigning manager id should be available in the EMPLOYEE table


EMPLOYEE
EMPID(PK)	ENAME		MANAGERID(FK)	SAL	DEPTNO
1001		KING		  NULL		5000	10
1002		SCOTT		  1001		4000	20
1003		JONES		  1002		4500	30
1004		SMITH		  1010		2000	20    => INVALID	  	

Create table employee
(empid number(4)
	constraint employee_empid_pk primary key,
 ename varchar(10),
 mgr number(4)
	constraint employee_mgr_self_fk REFERENCES employee(empid),
 sal number(8,2),
 deptno number(2)
);

Insert data into table :
------------------------

Insert into employee values ( &empid, &ename, &mgr, &sal, &deptno );


** If tables are mainitaing PRIMARY KEY & FOREING KEY relationships then We can not delete parent record if any    CHILD RECORDS are found

SQL> DELETE FROM DEPT_MAS WHERE DEPT_ID=20;
DELETE FROM DEPT_MAS WHERE DEPT_ID=20
*
ERROR at line 1:
ORA-02292: integrity constraint (ORA7PM.EMPLOY_DEPT_ID_FK) violated - child record found


ON DELETE CASCADE :
-------------------

  -> This option is used to whenever Parent record deleted then corresponding child records deleted 
     automatically

  -> This option will be added at the time Foreign key constraint declaration

Master Table :
--------------

SQL> select * from dept_mas;

DEPT_ID DEPT_NAME  DEPT_LOC
------- ---------- ----------
     10 Acc        Hyd
     20 Res        Sec
     30 Fin        Chennai
     40 Admin      Banglore

Ex:-
----

Create table employ
( eno number(4),
  ename varchar(20),
  sal number(8,2),
  dept_id number(2) References dept_mas(dept_id) ON DELETE CASCADE 
);

insert data to employ :
-----------------------
 
insert into employ values( 1, 'king', 5000, 10 );
insert into employ values( 2, 'scott', 4000, 20 );
insert into employ values( 3, 'jones', 2000, 30 );
insert into employ values( 4, 'smith', 5000, 10 );
insert into employ values( 5, 'allen', 3000, 10 );
commit;

SQL> select * from employ;

   ENO ENAME                   SAL DEPT_ID
------ -------------------- ------ -------
     1 king                   5000      10
     2 scott                  4000      20
     3 jones                  2000      30
     4 smith                  5000      10
     5 allen                  3000      10

Testing :
---------

Deleting parent record :
------------------------

SQL> delete from dept_mas where dept_id=20;

1 row deleted.

SQL> select * from dept_mas;

DEPT_ID DEPT_NAME  DEPT_LOC
------- ---------- ----------
     10 Acc        Hyd
     30 Fin        Chennai
     40 Admin      Banglore

SQL> select * from employ;

   ENO ENAME                   SAL DEPT_ID
------ -------------------- ------ -------
     1 king                   5000      10
     3 jones                  2000      30
     4 smith                  5000      10
     5 allen                  3000      10

ii. ON DELETE SET NULL :
------------------------

 -> this option is used to whenever Parent record deleted then corresponding child record
    column values set to NULLs
 
 -> this option also will be added at the time of FOREIGN KEY declaration

Ex:-

Master Table :
--------------

SQL> select * from dept_mas;

DEPT_ID DEPT_NAME  DEPT_LOC
------- ---------- ----------
     10 Acc        Hyd
     20 Res        Sec
     30 Fin        Chennai
     40 Admin      Banglore

Ex:-
----

Create table employ
( eno number(4),
  ename varchar(20),
  sal number(8,2),
  dept_id number(2) References dept_mas(dept_id) ON DELETE SET NULL
);

insert data to employ :
-----------------------
 
insert into employ values( 1, 'king', 5000, 10 );
insert into employ values( 2, 'scott', 4000, 20 );
insert into employ values( 3, 'jones', 2000, 30 );
insert into employ values( 4, 'smith', 5000, 10 );
insert into employ values( 5, 'allen', 3000, 10 );
commit;

SQL> select * from employ;

   ENO ENAME                   SAL DEPT_ID
------ -------------------- ------ -------
     1 king                   5000      10
     2 scott                  4000      20
     3 jones                  2000      30
     4 smith                  5000      10
     5 allen                  3000      10

Testing :
---------

Deleting parent record :
------------------------

SQL> delete from dept_mas where dept_id=10;

1 row deleted.

SQL> select * from dept_mas;

DEPT_ID DEPT_NAME  DEPT_LOC
------- ---------- ----------
     20 Res        Sec      
     30 Fin        Chennai
     40 Admin      Banglore

SQL> select * from employ;

   ENO ENAME                   SAL DEPT_ID
------ -------------------- ------ -------
     1 king                   5000       
     2 scott                  4000      20
     3 jones                  2000      30
     4 smith                  5000       
     5 allen                  3000       
 
COMPOSITE Constraints :
-----------------------

  -> A constraint is added to morethan one column is called as composite constraints
   
  -> In composite constraints maximum 32 columns are supported

  -> All composite constraints are supported in TABLE LEVEL / ALTER LEVEL

  -> In Composite constraints data is compared with PAIRWISE

Examples :
----------

i. Composite Primary key :
--------------------------

  -> primary key constraint is added to morethan one column is called as composite primary key

Ex:-

  -- create a product master table with company id, product id, product name

Validations:
------------

  -> company id and products ids are mandatory

  -> company id and product ids pair should not be repeat


prod_mas:
---------
cid	pid	pname
c1	p1	tea
c1	p2	coffee
c2	p1	tea
c1	p1	tea    => error



Table creation:
---------------

Create table prod_mas
( cid varchar(10),
  pid varchar(10),
  pname varchar(20),
     constraint prod_mas_cid_pid_pk primary key( cid, pid )
);

Checking :
----------

Insert into prod_mas values ( 'c1','p1','tea');
Insert into prod_mas values ( 'c1','p2','coffee');
Insert into prod_mas values ( 'c2','p1','tea');

SQL> Insert into prod_mas values ( 'c1','p1','tea');
Insert into prod_mas values ( 'c1','p1','tea')
*
ERROR at line 1:
ORA-00001: unique constraint (ORA8PM.PROD_MAS_CID_PID_PK) violated

SQL> select * from prod_mas;

CID        PID        PNAME
---------- ---------- --------------------
c1         p1         tea
c1         p2         coffee
c2         p1         tea
 

ii. composite foreign key :
---------------------------

  -> A Foreign key constraint is added to morethan one column is called as composite foreign key constraint

  -> Composite foreign key constraint is referenced with composite primary key constraint

Example :
---------

  -- create a sales table with sales id, sales date, cid, pid and amount

validations :
-------------

  -> selling cid and pid's should be matched with product master table of cid, pids

Table creation:
---------------

Create table sales
( sid number(4),
  sdate date,
  cid varchar(10),
  pid varchar(10),
  amt number(8,2),
    constraint sales_cid_pid_amt foreign key(cid, pid )
					REFERENCES prod_mas( cid, pid )
);


Checking :
----------

Insert Into sales values ( 1, sysdate, 'c1','p1',1000);
Insert Into sales values ( 2, sysdate, 'c1','p3',300);      => Error

iii. composite CHECK constraint :
---------------------------------

  -> check constraint is added to morethan one table is called as composite check constraint

ex:-

 -- employee salary + commission should not be exceeds rs.10000/-

Table creation:
---------------

create table emp_db
( eno number(2),
  ename varchar(10),
  sal number(8,2),
  comm number(7,2),
      constraint emp_db_sal_comm_chk ( sal + nvl(comm,0) <=10000 )
);

  
checking:
---------

Insert into emp_db values( 1, 'aaa', 5000, 1000);
Insert into emp_db values( 2, 'bbb', 8000, 3000);   => error
Insert into emp_db values( 2, 'bbb', 12000, null);   => error


** how to add constraints in ALTER Level :
------------------------------------------  

  -> After table creation to add constraints to db columns is called as ALTER LEVEL constraints

Ex:-

Create table std_db
( std_id varchar(10),
  std_name varchar(20),
  doj date,
  class varchar(10),
  Mobileno Number(2)
);

PRIMARY KEY :
-------------

 Alter table std_db ADD Constraint std_db_std_id_pk Primary key( std_id );

				or

 Alter table std_db ADD  Primary key( std_id );

Foreign key :
-------------

  Alter Table std_db ADD FOREIGN KEY ( std_id ) REFERENCES std_mas( std_id );

NOT NULL :
----------

 Alter table std_db MODIFY std_name NOT NULL;

UNIQUE :
--------

 Alter table std_db ADD std_db_mobileno_un UNIQUE( mobileno );

DEFAULT :
---------

 Alter table std_db MODIFY doj defualt sysdate;

CHECK constraint :
------------------

 Alter table std_db ADD CHECK ( Class in ( 'xi','xii' ))


** To see the created constraint names 

      select * from user_constraints;

** To see the constraints particular table

     select * from user_constraints where TABLE_NAME='EMPLOY';

** How to Enable / Disable constraints :
----------------------------------------

  -> By default all constraints are enabled

  -> to disable a constraint

        Alter table std_db disable constraint std_db_std_id_pk;

        Alter table std_db enable constraint std_db_std_id_pk;

** Dropping constraints :
-------------------------

   Alter table <table_name> DROP constraint <constraint_name>;

Ex:-

  Alter Table std_db drop constraint std_db_std_id_pk;


SUB-QUERIES :
-------------

What is a Query ?

  -> Query means to requesting data from databases

  -> Basically Queries are classified into 3 types

           i. Root Query

          ii. Parent Query

         iii. Child Query

i. Root Query :
---------------

  -> The query which is not depends upon another query output for it's conditional value is called as
     Root Query

         ex:   SELECT * FROM EMP;

ii. PARENT QUERY :
------------------

  -> The query which is depends upon another query output for it's conditional value is called as PARENT QUERY

               Ex: Select * from emp where sal = ( select max(sal) from emp );
                   ------------------------------
			parent query


iii. CHILD QUERY :
------------------

  -> the query which returns output to it's parent's query is called as CHILD QUERY

  -> Child query is also called as sub-query/ inner query / nested query/ Independent query, etc.,

               Ex: Select * from emp where sal = ( select max(sal) from emp );
					       -------------------------------
							child query


SUB-QUERIES :
-------------

  -> Query within a query is called as sub-query

  -> Sub-queries are supported by SELECT, UPDATE, DELETE & INSERT commands

  -> Generally sub-queries are placed in WHERE Clause of SELECT statement

  -> Sub-queries are placed in FROM clause and column_list of OUTER QUERY

  -> if sub-queries are placed in FROM Clause that type of queries are called as IN-LINE sub-queries

           ex:  SELECT * FROM (   );

  
  -> if sub-queries are placed in COLUMN_LIST of outer query is called as SCALAR SUB-QUERIES          
 
           syn: Select col1, col2, (   ) , col3,... from <table_name>;  

restrictions:
-------------

  -> Sub-queries must be enclosed within the brackets  (  )

      
  -> Sub-Queries are not supported ORDER BY clause but, only IN-LINE Sub-queries are supported


  -> Maximum 255 sub-queries can be nested

Adv. :
-------

  -> By using sub-queries it improves the performance while retrieving or manipulating data

TYPES OF SUB-QUERIES :
----------------------

 -> ORACLE Supports 5 types of Sub-Queries

       i. Single row sub-queries

      ii. Multi row sub-queries

     iii. Multi-column sub-queries

      iv. Co-related sub-queries

       v. Scalar Sub-queries

** In single row, multi-row and  multi-column sub-queries first sub-query is executed, depends upon output of
   sub-query the parent query will be executed.

i. Single row sub-query :
-------------------------

  -> Sub-query returns single value is called as single row sub-queries

  -> In single row sub-queries sub-query outputs are compared with >, <, >=,<=, =, BETWEEN, NOT BETWEEN, Etc.,      operators

Examples:
---------

  -- waq to display JONES employee and his COLEAGUES


SQL> select deptno from emp where ename='JONES';

DEPTNO
------
    20

SQL> SELECT ENAME FROM EMP WHERE DEPTNO=20;

ENAME
----------
HEMANTH
JONES
SCOTT
ADAMS
ARCHANA 

SQL>       select ename from emp where deptno=(select deptno from emp where ename='JONES');

ENAME
----------
HEMANTH
JONES
SCOTT
ADAMS
ARCHANA


-- waq to display maximum salary employee details

	select * from emp where sal=( select max(sal) from emp );

-- waq to display who are joined after joining of FORD employee

SQL> SELECT * FROM EMP WHERE HIREDATE > ( select hiredate from emp where ename='SCOTT');

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7876 ADAMS      CLERK       7788 12-JAN-83   1100            20

-- waq to display 2nd highest salary

SQL> select max(sal) from emp where sal < (select max(sal) from emp);

MAX(SAL)
--------
    3000

-- waq to display 3rd highest salary 

SQL>   select max(sal) from emp where sal< (select max(sal) from emp where sal < (select max(sal) from emp) );

MAX(SAL)
--------
    2975

-- WAQ TO latest employee joining details

SQL> select * from emp where hiredate=(select max(hiredate) from emp);

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7876 ADAMS      CLERK       7788 12-JAN-83   1100            20


-- waq to display senior most employee record

SQL> select * from emp where hiredate=(select min(hiredate) from emp);

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 HEMANTH    CLERK       7902 17-DEC-80    800            20 

-- waq to display who are working in NEW YORK location

SQL> SELECT * FROM EMP WHERE DEPTNO= ( SELECT DEPTNO FROM DEPT WHERE LOC='NEW YORK');

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7782 CLARK      MANAGER     7839 09-JUN-81   2450            10
  7839 KING       PRESIDENT        17-NOV-81   5000            10
  7934 MILLER     CLERK       7782 23-JAN-82   1300            10


-- waq to display who are joined SALES dept. in 1981 

SQL> SELECT * FROM EMP WHERE DEPTNO= ( SELECT DEPTNO FROM DEPT WHERE DNAME='SALES')
                                                       AND
                                         HIREDATE LIKE '%81';

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1600    300     30
  7521 WARD       SALESMAN    7698 22-FEB-81   1250    500     30
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1250   1400     30
  7698 BLAKE      MANAGER     7839 01-MAY-81   2850            30
  7844 TURNER     SALESMAN    7698 08-SEP-81   1500      0     30
  7900 JAMES      CLERK       7698 03-DEC-81    950            30

6 rows selected.


II. MULTI-ROW SUB-QUERIES :
---------------------------

    -> if sub-query returns morethan one value is called as Multi-row sub-queries

    -> In multi-row sub-queries, sub-query outputs are compared with special operators those are
       IN, ANY, ALL & EXISTS operator

Ex:-

  -- write a query to display who are working in ACCOUNTING and SALES depts.

SQL> select deptno from dept where dname='ACCOUNTING' OR DNAME='SALES';

DEPTNO
------
    10
    30

SQL> SELECT * FROM EMP WHERE DEPTNO IN (  select deptno from dept where dname='ACCOUNTING' OR DNAME='SALES');

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7499 ALLEN      SALESMAN    7698 20-FEB-81   2700    300     30
  7521 WARD       SALESMAN    7698 07-JAN-22   1740    500     30
  7654 MARTIN     SALESMAN    7698 28-SEP-81   2175   1400     30
  7698 BLAKE      MANAGER     7839 01-MAY-81   4575            30
  7782 CLARK      MANAGER     7839 09-JUN-81   3975            10
  7839 KING       PRESIDENT        17-NOV-81   7800            10
  7844 TURNER     SALESMAN    7698 08-SEP-81   2550      0     30
  7900 JAMES      CLERK       7698 03-DEC-81   1725            30
  7934 MILLER     CLERK       7782 23-JAN-82   2250            10

9 rows selected.


-- Waq to display only BOSSES( superior) names

SQL> select ename as Superior from emp where empno in ( select mgr from emp );

SUPERIOR
----------
FORD
BLAKE
KING
JONES
CLARK
   
ex:-  waq to display who are getting morethan ALL Salesman Salaries

	
SQL> SELECT * FROM EMP WHERE SAL >ALL( select sal from emp where job='SALESMAN');

SQL> select sal from emp where job='SALESMAN';

   SAL
------
  2700
  1740
  2175
  2550

SQL>  SELECT * FROM EMP WHERE SAL >ALL( select sal from emp where job='SALESMAN');

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7902 FORD       ANALYST     7566 21-DEC-21   3840            20
  7782 CLARK      MANAGER     7839 09-JUN-81   3975            10
  7698 BLAKE      MANAGER     7839 01-MAY-81   4575            30
  7566 JONES      MANAGER     7839 02-APR-81 4762.5            20
  7839 KING       PRESIDENT        17-NOV-81   7800            10

   SAL
------
  2700
  1740
  2175
  2550	


X    > ALL
5000
2500  X
1800  X
3500


-- WAq to display who are getting less any from SALESMAN salaries


   SAL
------
  2700
  1740
  2175
  2550	


X    < ANY
5000 X
2500    
1800   
3500 X

SQL>  SELECT * FROM EMP WHERE SAL <ANY( select sal from emp where job='SALESMAN');

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 01-JAN-22   1200            20
  7900 JAMES      CLERK       7698 03-DEC-81   1725            30
  7521 WARD       SALESMAN    7698 07-JAN-22   1740    500     30
  7876 ADAMS      CLERK       7788 12-JAN-83   1950            20
  7654 MARTIN     SALESMAN    7698 28-SEP-81   2175   1400     30
  7934 MILLER     CLERK       7782 23-JAN-82   2250            10
  7844 TURNER     SALESMAN    7698 08-SEP-81   2550      0     30

III. Multi-column sub-queries :
-------------------------------

  -> Sub-query returns morethan one column is called as Multi-column sub-queries

  -> In Multi-column sub-queries, no.of columns returns by Sub-query should be matched with
     No.of columns in WHERE clause of OUTER QUERY and corresponding columns datatypes should be same.

        syn: Select * from <table_name> WHERE ( col1, col2 ) IN ( SELECT col3, col4 from <table_name> );

  -> Multi-column sub-queries sub-query outputs are compared with Pairwise so, these queries are called 
     Pair-wise sub-queries

  
ex:-  waq to display dept.wise maximum salary employee details

SQL> select * from emp where (deptno, sal ) in ( select deptno, max(sal) from emp group by deptno);

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7698 BLAKE      MANAGER     7839 01-MAY-81   4575            30
  7566 JONES      MANAGER     7839 02-APR-81 4762.5            20
  7839 KING       PRESIDENT        17-NOV-81   7800            10

ex:-

product_mas
-----------
cid	pid	pname
c1	p1	tea
c1	p2	coffee
c2	p1	tea

sales
------
sid	sdate	cid	pid	qty	amount
		c1	p1	5	1000
		c1	p2	10	5000



-- waq to display selling items product names

    SELECT Pname from prod_mas where ( cid, pid ) IN ( Select cid, pid from sales);

IV. Co-Related Sub-Queries :
----------------------------

  -> In Co-related sub-queries first Outer Query executed, depends upon output of Outer Query the Inner query 
     will be executed

  -> if Outer query executes 'n' times, then sub-query also executed 'n' times

  -> one of the outer query column is placed in sub-query WHERE Condition that outer query column is called as 
     co-related column

     syn: select col1, col2,... from <table_name>
					where col2 = ( select col3 from <table_name>
										where col3=col1);

Example:
--------

  -- waq to display who are getting more than their dept. avg. salaries

EMP
EMPno	ENAME	SAL	DEPTNO
1001	KING	5000	10
1002	SCOTT	4000	20  x
1003	JONES	3000	30  
1004	SMITH	800	10  x 
1005	BLAKE	6000	20
1005	ALLEN	1500	30  x


-- waq to display who are getting morethan their dept. avg. salaries

deptno  avg.sal
10  	2900
20  	5000
30  	2250
             1002	SCOTT	4000	20
    Select e.Empno, e.Ename, e.sal, e.deptno from emp e        5000  
					where e.sal > ( select avg(sal) from emp
						4000		where deptno = e.deptno );
										20


  Select e.Empno, e.Ename, e.sal, e.deptno from emp e         
					where e.sal > ( select avg(sal) from emp
						 		where deptno = e.deptno );

-- waq to display who are getting less than their jobs maximum salaries


    select e.empno, e.ename, e.job, e.sal, e.deptno from emp e
					where e.sal < ( select max(sal) from emp 
									where job = e.job );
 EMPNO ENAME      JOB          SAL DEPTNO
------ ---------- --------- ------ ------
  7369 SMITH      CLERK       1200     20
  7521 WARD       SALESMAN    1740     30
  7654 MARTIN     SALESMAN    2175     30
  7698 BLAKE      MANAGER     4575     30
  7782 CLARK      MANAGER     3975     10
  7844 TURNER     SALESMAN    2550     30
  7876 ADAMS      CLERK       1950     20
  7900 JAMES      CLERK       1725     30

8 rows selected.

SQL> select job, max(sal) from emp group by job;

JOB       MAX(SAL)
--------- --------
CLERK         2250
SALESMAN      2700
PRESIDENT     7900
MANAGER     4762.5
ANALYST       3840


EXISTS :
--------

  -> EXISTS operator returns BOOLEAN value ( TRUE / FALSE )

  -> If Sub-query executes successfully and it returns atleast one record then EXISTS returns TRUE

  -> If Sub-query executes successfully and it doesn't returns any record then EXISTS returns FALSE 


ex:- waq to display working employee dept. details

SQL> select d.deptno, d.dname, d.loc from Dept d  where EXISTS ( select * from emp e where e.deptno=d.deptno)
                  order by d.deptno;

DEPTNO DNAME          LOC
------ -------------- -------------
    10 ACCOUNTING     NEW YORK
    20 RESEARCH       DALLAS
    30 SALES          CHICAGO


-- waq to display not working employee dept.details

SQL> select d.deptno, d.dname, d.loc from Dept d  where NOT EXISTS ( select * from emp e 
									where e.deptno=d.deptno)
                   order by d.deptno;

DEPTNO DNAME          LOC
------ -------------- -------------
    40 OPERATIONS     BOSTON
    50 MATHS          hyd


V. SCALAR Sub-queries :
-----------------------

  -> Sub-queries are placed in COLUMN LIST of outer query is called as SCALAR Sub-queries

  -> In Scalar sub-queries sub-query should be returns single column and single value

ex:-

SQL>    select e.empno, e.ename, e.sal, e.deptno, ( select sum(sal) from emp ) from emp e;

 EMPNO ENAME         SAL DEPTNO (SELECTSUM(SAL)FROMEMP)
------ ---------- ------ ------ -----------------------
  7369 SMITH        1200     20                   41343
  7499 ALLEN        2700     30                   41343
  7521 WARD         1740     30                   41343
  7566 JONES      4762.5     20                   41343
  7654 MARTIN       2175     30                   41343

-- waq to display dept.wise sum of salaries with dept. pct

     select deptno, sum(sal) as dept_totsal,
            (select sum(sal) from emp ) as totsal, (sum(sal)/(select sum(sal) from emp))*100 as pct
	from emp 
	    group by deptno;

DEPTNO DEPT_TOTSAL TOTSAL    PCT
------ ----------- ------ ------
    30       15465  41343 37.407
    20       11753  41343 28.427
    10       14125  41343 34.166        

-- waq to display following output

deptno	dname		min(sal)	max(sal)	sum(sal)		
10 	accounting	800		5000		14000
.
.
.


-- waq display dept.name wise no.of employees are working

accounting	3
research	6
.
.
.


Nested SELECT :
===============

  -> SELECT within the SELECT is called as Nested SELECT

ex:-
 
 SELECT ( SELECT COUNT(*) FROM EMP ) AS NO_OF_EMPS,
	( SELECT COUNT(*) FROM DEPT ) AS NO_OF_DEPTS,
	( SELECT COUNT(*) FROM SALGRADE) AS NO_OF_GRADES
 FROM DUAL;

NO_OF_EMPS NO_OF_DEPTS NO_OF_GRADES
---------- ----------- ------------
        13           5            5

PSEUDO COLUMNS :
----------------

  -> Oracle pre-defined columns are called as Pseudo columns

  -> Pseudo column is a column not related to one table and it is applicable for any table

  -> Oracle supports different types of pseudo columns

i. UID

ii. USER

iii. SYSDATE

iv. SYSTIMESTAMP

v. ROWID

vi. ROWNUM

vii. LEVEL

viii. CURRVAL

ix. NEXTVAL

i. UID :
--------

  -> it returns currently connected user identification number

ii. USER :
----------

  -> it returns currently connected user name

iii. SYSDATE:
-------------

  -> it returns current server date and time

iv. SYSTIMESTAMP :
------------------

  -> it returns current server date and time physically


Example:
--------

  create table user_details ( user_id varchar(10), user_name varchar(20),
			      login_time date, logout_time timestamp );



SQL> Insert into user_details values ( uid, user, sysdate, systimestamp );

1 row created.

SQL>
SQL> select * from user_details;

USER_ID    USER_NAME            LOGIN_TIM
---------- -------------------- ---------
LOGOUT_TIME
---------------------------------------------------------------------------
52         ORA8PM               27-JAN-22
27-JAN-22 08.17.26.595000 PM


v. ROWID :
----------

  -> Rowid is an UNIQUE value

  -> Rowid's are generated at the time of Inserting data into table

  -> Rowid's are stored in db permanently

  -> It contains 16bit hexa-decimal value

  -> that hexa-decimal contains FILE ID, BLOCK ID and RECORD ID

  -> Rowid returns position of record

  -> Rowid's are re-usable components

Ex:-


SQL>   Select Rowid, Empno, Ename, Job, Sal, Deptno from emp;

ROWID               EMPNO ENAME      JOB          SAL DEPTNO
------------------ ------ ---------- --------- ------ ------
AAAFFtAABAAALQRAAA   7369 HEMANTH    CLERK        800     20
AAAFFtAABAAALQRAAB   7499 ALLEN      SALESMAN    1600     30
AAAFFtAABAAALQRAAC   7521 WARD       SALESMAN    1250     30
AAAFFtAABAAALQRAAD   7566 JONES      MANAGER     2975     20
AAAFFtAABAAALQRAAE   7654 MARTIN     SALESMAN    1250     30
AAAFFtAABAAALQRAAF   7698 BLAKE      MANAGER     2850     30 


SQL>  Select rowid, Deptno, Dname, Loc from dept;

ROWID              DEPTNO DNAME          LOC
------------------ ------ -------------- -------------
AAAFFuAABAAALQZAAA     10 ACCOUNTING     NEW YORK
AAAFFuAABAAALQZAAB     20 RESEARCH       DALLAS
AAAFFuAABAAALQZAAC     30 SALES          CHICAGO
AAAFFuAABAAALQZAAD     40 OPERATIONS     BOSTON


Other examples:
---------------

 -- write a query to display first record from the table

SQL> select * from emp where rowid= ( select min(rowid) from emp);

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 HEMANTH    CLERK       7902 17-DEC-80    800            20

-- write a to display last record from the table

SQL> select * from emp where rowid= ( select max(rowid) from emp);

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7934 MILLER     CLERK       7782 23-JAN-82   1300            10

ex:- 

** waq to Display duplicate records from the table

Table creation:
---------------

  Create table emp_db( eno number(4), ename varchar(10) );

  Insert into emp_db VALUES ( 1,'king' );
  Insert into emp_db values ( 2,'scott' );
  Insert into emp_db values ( 1,'king' );
  Insert into emp_db values ( 3,'jones' );
  Insert into emp_db values ( 4,'smith' );
  Insert into emp_db values ( 3,'jones' );
  commit;

SQL> select * from emp_db;

SQL> select rowid, eno, ename from emp_db;

ROWID                 ENO ENAME
------------------ ------ ----------
AAAFMFAABAAALRpAAA      1 king
AAAFMFAABAAALRpAAB      2 scott
AAAFMFAABAAALRpAAC      1 king
AAAFMFAABAAALRpAAD      3 jones
AAAFMFAABAAALRpAAE      4 smith
AAAFMFAABAAALRpAAF      3 jones

6 rows selected.


 select * from emp_db    
    where rowid not in(	select min(rowid) from emp_db group by eno);
				 AAA
				 AAB
				 AAD
				 AAE 

				
output:
-------

   ENO ENAME
------ ----------
     3 jones
     1 king


-- write a query to Delete/remove duplicate records from the table

Delete from emp_db    
    where rowid not in(	select min(rowid) from emp_db group by eno);
				 AAA
				 AAB
				 AAD
				 AAE 

output:
-------

SQL> select rowid, eno, ename from emp_db;

ROWID                 ENO ENAME
------------------ ------ ----------
AAAFMFAABAAALRpAAA      1 king
AAAFMFAABAAALRpAAB      2 scott
AAAFMFAABAAALRpAAD      3 jones
AAAFMFAABAAALRpAAE      4 smith


vi. ROWNUM :
------------

  -> Rownum is an UNIQUE value

  -> Rownums are generated at time of SELECTING data from db tables

  -> Rownum is a dynamic value

  -> Rownums are not stored in DB permanently

  -> Rownum returns position of record

  -> After fetching data from db tables then rownums are generated so, on rownum
     pseudo column < and <= are supported, >, >=, =, between, not between, these are not supported

Ex:-

SQL>   Select rownum, empno, ename, job, sal, deptno from emp;

ROWNUM  EMPNO ENAME      JOB          SAL DEPTNO
------ ------ ---------- --------- ------ ------
     1   7369 HEMANTH    CLERK        800     20
     2   7499 ALLEN      SALESMAN    1600     30
     3   7521 WARD       SALESMAN    1250     30
     4   7566 JONES      MANAGER     2975     20
     5   7654 MARTIN     SALESMAN    1250     30
     6   7698 BLAKE      MANAGER     2850     30
     7   7782 CLARK      MANAGER     2450     10
     8   7788 SCOTT      ANALYST     3000     20
     9   7839 KING       PRESIDENT   5000     10
    10   7844 TURNER     SALESMAN    1500     30
    11   7876 ADAMS      CLERK       1100     20
    12   7900 JAMES      CLERK        950     30
    13   7902 ARCHANA    ANALYST     3000     20
    14   7934 MILLER     CLERK       1300     10

14 rows selected.

SQL>   Select rownum, empno, ename, job, sal, deptno from emp where deptno=10;

ROWNUM  EMPNO ENAME      JOB          SAL DEPTNO
------ ------ ---------- --------- ------ ------
     1   7782 CLARK      MANAGER     2450     10
     2   7839 KING       PRESIDENT   5000     10
     3   7934 MILLER     CLERK       1300     10

SQL> select rownum, deptno, dname, loc from dept;

ROWNUM DEPTNO DNAME          LOC
------ ------ -------------- -------------
     1     10 ACCOUNTING     NEW YORK
     2     20 RESEARCH       DALLAS
     3     30 SALES          CHICAGO
     4     40 OPERATIONS     BOSTON


Other Examples:
---------------

 -- write a query to display first two records from the table

SQL> select * from emp where rownum<=2;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 HEMANTH    CLERK       7902 17-DEC-80    800            20
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1600    300     30

-- waq to display LAST two records from the table


MINUS :
-------

  -> It is one of the oracle set operator

  -> Set Operators are used to join outputs of SELECT statements

  -> MINUS is one of the SET operator and It displays un-matched records from query1
     compare to query2

Select job from emp where deptno=10
set operator
Select job from emp where deptno=20;


A = { 1, 2, 4, 5 }

B = { 1, 5, 6 }

A - B = { 2, 4 }


Ex: SELECT * FROM EMP WHERE ROWNUM<=14
             MINUS
    SELECT * FROM EMP WHERE ROWNUM<=12;


 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7902 ARCHANA    ANALYST     7566 03-DEC-81   3000            20
  7934 MILLER     CLERK       7782 23-JAN-82   1300            10

note: above query is static query, because if table contains different no.of record you can change query each       and every time.

  
** to write the query dynamically...

select * from emp where rownum <=( select count(*) from emp)
minus
select * from emp where rownum <=( select count(*)-2 from emp);


** waq to generate bank mini statement

select * from bank_trans where rownum <=( select count(*) from bank_trans)
minus
select * from bank_trans where rownum <=( select count(*)-10 from bank_trans);


-- waq to display top-5 maximum salaries

SQL> select rownum, sal from ( select rownum, sal from emp order by sal desc )
            where rownum<=5;

ROWNUM    SAL
------ ------
     1   5000
     2   3000
     3   3000
     4   2975
     5   2850

SQL> select sal from ( select sal from emp order by sal desc )
            where rownum<=5;

   SAL
------
  5000
  3000
  3000
  2975
  2850

-- waq to display Nth maximum salary

SQL> select rownum, sal from ( select rownum, sal from emp order by sal desc )
            group by rownum, sal having rownum=&n;
Enter value for n: 1

ROWNUM    SAL
------ ------
     1   5000

SQL> /
Enter value for n: 5

ROWNUM    SAL
------ ------
     5   2850

SQL> /
Enter value for n: 11

ROWNUM    SAL
------ ------
    11   1250

-- waq to display alter records( even records )

select rownum, empno, ename, job, sal, deptno from emp 
            group by rownum, empno, ename, job, sal, deptno having mod(rownum,2)=0
                      order by rownum;

ROWNUM  EMPNO ENAME      JOB          SAL DEPTNO
------ ------ ---------- --------- ------ ------
     2   7499 ALLEN      SALESMAN    1600     30
     4   7566 JONES      MANAGER     2975     20
     6   7698 BLAKE      MANAGER     2850     30
     8   7788 SCOTT      ANALYST     3000     20
    10   7844 TURNER     SALESMAN    1500     30
    12   7900 JAMES      CLERK        950     30
    14   7934 MILLER     CLERK       1300     10

7 rows selected.

LEVEL pseudo column :
---------------------

  -> It will arrange the select statement output with INVERTED TREE STRUCTURE

  -> It returns a number

  -> Level pseudo column executed on Hierarchical queries

  
Hierarchical queries :
----------------------

 -> these are queries that are executed upon the tables that contains hierarchical data

 -> if table contains SELF FOREIGN KEY/SELF REFERENCE that table is a Hierarchical data

 -> to write the hierarchical queries we need the following....

          i. start with : It is used to identify root node of the hierarchy
                          if start with is omitted then oralce used all records in the table as root rows

         
         ii. connect by prior : it is used to establish relationship between root node and child node of the
                                hierarchy

         
        iii. where : used to filter the data without affecting other rows of the hierarhcy

Emp
----
empno	ename	mgr
-----	-----	-----
7369	smith 	7902
7499	allen	7698
7566	jones	7839
7698	blake	7839
7788	scott	7566
7839	king
7902	ford	7566


-- waq to display KING's employee hierarchy


        select ename from emp 
			start with ename='KING'
				connect by prior empno=mgr;
						 7566 = 


				KING(7839)

			JONES(7566)     	 BLAKE(7698)

		SCOTT(7788)	FORD(7902)    ALLEN(7499)
			     
			     SMITH(7369)
                          

o/p:

ename
------
king
jones
scott
ford
smith
blake
allen


  
** to display output with Hierarhchical format then oracle db provides one pre-defined procedure is

                     sys_connect_by_path


Ex:-

    select sys_connect_by_path(ename, '\') as org_char 
				from emp
				     start with ename='KING'
						Connect by prior  empno = mgr;

ORG_CHAR
----------------------------------------------------------------------------------------------------
\KING
\KING\JONES
\KING\JONES\SCOTT
\KING\JONES\SCOTT\ADAMS
\KING\JONES\ARCHANA
\KING\JONES\ARCHANA\HEMANTH
\KING\BLAKE
\KING\BLAKE\ALLEN
\KING\BLAKE\WARD
\KING\BLAKE\MARTIN
\KING\BLAKE\TURNER
\KING\BLAKE\JAMES
\KING\CLARK
\KING\CLARK\MILLER

14 rows selected.


using LEVEL pseudo column :
---------------------------

sql> column org_chart format a40

sql>    select level, sys_connect_by_path(ename, '\') as org_chart
				from emp
				     start with ename='KING'
						Connect by prior  empno = mgr;
  
 LEVEL ORG_CHART
------ ----------------------------------------
     1 \KING
     2 \KING\JONES
     3 \KING\JONES\SCOTT
     4 \KING\JONES\SCOTT\ADAMS
     3 \KING\JONES\ARCHANA
     4 \KING\JONES\ARCHANA\HEMANTH
     2 \KING\BLAKE
     3 \KING\BLAKE\ALLEN
     3 \KING\BLAKE\WARD
     3 \KING\BLAKE\MARTIN
     3 \KING\BLAKE\TURNER
     3 \KING\BLAKE\JAMES
     2 \KING\CLARK
     3 \KING\CLARK\MILLER

14 rows selected.


note: on NORMAL SQL queries LEVEL pseudo column not supported.



JOINS :
-------

  -> To retrieving data from morethan one table in a single query by using JOINS

  -> Joins are best example for Relational Databases

syn:-

   Select table1.col1, table1.col2, table2.col1, table2.col2,... from <table1>, <table2>,..
								where <table1.col1>=<table2.col1>;

  -> Join queries are supported only SELECT statement

  -> if 'n' tables are joined there will be mini. 'n-1' join conditions are required

  -> Join queries are main used for to generate reports like invoices, salary statements, daily reports,
     weekly reports, student progross reports, etc.,

Types of Jions :
----------------

  -> Oracle supports 5 types of Joins

I. EQUI JOIN / INNER JOIN

II. NON-EQUI JOIN

III. CARTESIAN JOIN

IV. OUTER JOINS

V. SELF JOINS


  -> To write any type of equi join, oracle returns one common error message is ambuigty

SQL> select deptno from emp, dept;
select deptno from emp, dept
       *
ERROR at line 1:
ORA-00918: column ambiguously defined 

** to overcome this error message preceeding common column names to use TABLE NAMES or TABLE ALAISES

Table Aliase :
--------------

  -> Alaise name is given to next to table name is called as Table Aliase

           ex: employee_master_table emt, Employee_Transaction_Table ett, etc.,

  -> By using table aliases to improves the performance

I. EQUI JOIN / INNER JOIN :
---------------------------

  -> To retrieving data from morethan one table in a single query by using Equality Operator in Join 
     condition is called as Equi Join

  -> To write equi join queries, Joing tables should be contains atleast one similar column name and 
     corresponding columns datatypes should be same.


Example :
---------

  -- waq to display employee details and corresponding each employee dept.details

SQL> select * from emp , dept where emp.deptno=dept.deptno;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO DEPTNO DNAME          LOC
------ ---------- --------- ------ --------- ------ ------ ------ ------ -------------- -------------
  7369 SMITH      CLERK       7902 17-DEC-80    800            20     20 RESEARCH       DALLAS
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1600    300     30     30 SALES          CHICAGO
  7521 WARD       SALESMAN    7698 22-FEB-81   1250    500     30     30 SALES          CHICAGO
  7566 JONES      MANAGER     7839 02-APR-81   2975            20     20 RESEARCH       DALLAS
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1250   1400     30     30 SALES          CHICAGO
  7698 BLAKE      MANAGER     7839 01-MAY-81   2850            30     30 SALES          CHICAGO


-- waq to display who are working NEW YORK location

SQL> select empno, ename, job, sal, emp.deptno, dept.deptno, dname, loc
                                 from emp, dept where emp.deptno = dept.deptno
                                                                   and
                                                              loc='NEW YORK';

 EMPNO ENAME      JOB          SAL DEPTNO DEPTNO DNAME          LOC
------ ---------- --------- ------ ------ ------ -------------- -------------
  7782 CLARK      MANAGER     2450     10     10 ACCOUNTING     NEW YORK
  7839 KING       PRESIDENT   5000     10     10 ACCOUNTING     NEW YORK
  7934 MILLER     CLERK       1300     10     10 ACCOUNTING     NEW YORK

-- waq to display who are joined 1981 in SALES dept.

select empno, ename, job, sal, emp.deptno, dept.deptno, dname, loc
                                 from emp, dept where emp.deptno = dept.deptno  
							         and
						to_char(hiredate,'yyyy')=1981
								 and
							dname='SALES';

 EMPNO ENAME      JOB          SAL DEPTNO DEPTNO DNAME          LOC
------ ---------- --------- ------ ------ ------ -------------- -------------
  7499 ALLEN      SALESMAN    1600     30     30 SALES          CHICAGO
  7521 WARD       SALESMAN    1250     30     30 SALES          CHICAGO
  7654 MARTIN     SALESMAN    1250     30     30 SALES          CHICAGO
  7698 BLAKE      MANAGER     2850     30     30 SALES          CHICAGO
  7844 TURNER     SALESMAN    1500     30     30 SALES          CHICAGO
  7900 JAMES      CLERK        950     30     30 SALES          CHICAGO

6 rows selected.


-- waq to display who are getting morethan rs.2000 in ACCOUNTING and RESEARCH depts.


SQL> select empno, ename, job, sal, emp.deptno, dept.deptno, dname, loc
                                   from emp, dept where emp.deptno = dept.deptno
                                                             and
                                                dname in ('ACCOUNTING','RESEARCH')
                                                             AND
                                                        SAL > 2000;

 EMPNO ENAME      JOB          SAL DEPTNO DEPTNO DNAME          LOC
------ ---------- --------- ------ ------ ------ -------------- -------------
  7566 JONES      MANAGER     2975     20     20 RESEARCH       DALLAS
  7782 CLARK      MANAGER     2450     10     10 ACCOUNTING     NEW YORK
  7788 SCOTT      ANALYST     3000     20     20 RESEARCH       DALLAS
  7839 KING       PRESIDENT   5000     10     10 ACCOUNTING     NEW YORK
  7902 FORD       ANALYST     3000     20     20 RESEARCH       DALLAS

OTHER Examples :
----------------

Bank_Mas :  Accno, Cname, Odate, acc_type, Balance
	     sbi1  king   ----	    s       700

Bank_Trans:  Tno, Accno, Tdate, Ttype, Tamount 
              1     sbi1 -----   d     1000


-- waq to display SBI1 customer details and his transaction details for the month of APRIL 2021

    Select * from Bank_Mas, Bank_trans
				where bank_mas.accno = bank_trans.accno
						   and
					   bank_mas.accno='sbi'
						   and
					    tdate like '%-apr-2021';

-- waq to display SBI1 customer last month details

    Select * from Bank_Mas, Bank_trans
				where bank_mas.accno = bank_trans.accno
						   and
					   bank_mas.accno='sbi'
						   and
		       to_char(tdate,'mm-yyyy') =   to_char( add_months(sysdate,-1),'mm-yyyy');


-- waq to dislay SBI1 Customer current month till date details

    Select * from Bank_Mas, Bank_trans
				where bank_mas.accno = bank_trans.accno
						   and
					   bank_mas.accno='sbi'
						   and
				to_char(hiredate,'mm-yyyy')=to_char(sysdate,'mm-yyyy');

-- waq to display bank mini statement 

 select * from (select bank_mas.accno, cname, tdate, ttype, tamount from bank_mas, bank_trans
					where bank_mas.accno = bank_trans.accno 
							   and
						bank_mas.accno='sbi1'
							order by tdate desc)
        							  where rownum <=10;

II. NON-EQUI JOIN :
-------------------

  -> To retrieving data from morethan one table in a single query without using Equality Operator is called
     as Non-Equi Join

  -> In Non-Equi Queries, Join conditions are compared with >, <, >=, <=, between, not between, etc., operators

Example:
--------

  -- waq to display employee details and corresponding each employee grades

SQL> SELECT emp.*, Grade FROM EMP , SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO  GRADE
------ ---------- --------- ------ --------- ------ ------ ------ ------
  7369 SMITH      CLERK       7902 17-DEC-80    800            20      1
  7876 ADAMS      CLERK       7788 12-JAN-83   1100            20      1
  7900 JAMES      CLERK       7698 03-DEC-81    950            30      1
  7521 WARD       SALESMAN    7698 22-FEB-81   1250    500     30      2
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1250   1400     30      2
  7934 MILLER     CLERK       7782 23-JAN-82   1300            10      2
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1600    300     30      3
  7844 TURNER     SALESMAN    7698 08-SEP-81   1500      0     30      3
  7566 JONES      MANAGER     7839 02-APR-81   2975            20      4
  7698 BLAKE      MANAGER     7839 01-MAY-81   2850            30      4
  7782 CLARK      MANAGER     7839 09-JUN-81   2450            10      4
  7788 SCOTT      ANALYST     7566 09-DEC-82   3000            20      4
  7902 FORD       ANALYST     7566 03-DEC-81   3000            20      4
  7839 KING       PRESIDENT        17-NOV-81   5000            10      5

14 rows selected.


Example for Equi + Non-Equi :
-----------------------------

  -- waq to display employee name corresponding employee dept.dname with grades

select ename, dname, grade
		from emp, dept, salgrade
			where emp.deptno = dept.deptno
					and
				sal between losal and hisal;

ENAME      DNAME           GRADE
---------- -------------- ------
SMITH      RESEARCH            1
ALLEN      SALES               3
WARD       SALES               2
JONES      RESEARCH            4
MARTIN     SALES               2
BLAKE      SALES               4
CLARK      ACCOUNTING          4
SCOTT      RESEARCH            4
KING       ACCOUNTING          5
TURNER     SALES               3
ADAMS      RESEARCH            1
JAMES      SALES               1
FORD       RESEARCH            4
MILLER     ACCOUNTING          2

14 rows selected.				


III. CARTESIAN JOIN :
---------------------

  -> To retrieving data from morethan one table in a single query without using any condition is called as
     Cartesian Join

  -> In cartesian joins outputs dislays like no.of records  in table1 x no.of records in table2

  -> Cartesian join is also called as Cross Join

Ex:-

A = { 1, 2, 3 }

B = { 4, 5 }

A x B = { (1,4),(1,5),(2,4),(2,5),(3,4),(3,5) }

Ex:-

   Select * from Emp, Dept;

IV. OUTER JOINS :
------------------

 -> In this first it displays mathching records from  Table1, Table2 and un-matched records from either
    table1 or table2 or both tables

 -> Outer joins are classified into 3 types

            i. Right Outer Join

           ii. Left Outer Join

          iii. Full Outer Join

** from oracle 10g onwards outer represented with (+) symbol

i. right outer join :
---------------------

  -> In this joins, first it displays matching records from table1, table2 and un-matched records from 
     right side of the table on JOIN condition.


ex:-  

    Select Empno , Ename, Job, Sal, Emp.Deptno, 
				Dept.Deptno, Dname, Loc
					    from emp, Dept
						where emp.deptno(+)=dept.deptno;

 EMPNO ENAME      JOB          SAL DEPTNO DEPTNO DNAME          LOC
------ ---------- --------- ------ ------ ------ -------------- -------------
  7369 SMITH      CLERK        800     20     20 RESEARCH       DALLAS
  7499 ALLEN      SALESMAN    1600     30     30 SALES          CHICAGO
  7521 WARD       SALESMAN    1250     30     30 SALES          CHICAGO
  7566 JONES      MANAGER     2975     20     20 RESEARCH       DALLAS
  7654 MARTIN     SALESMAN    1250     30     30 SALES          CHICAGO
  7698 BLAKE      MANAGER     2850     30     30 SALES          CHICAGO
  7782 CLARK      MANAGER     2450     10     10 ACCOUNTING     NEW YORK
  7788 SCOTT      ANALYST     3000     20     20 RESEARCH       DALLAS
  7839 KING       PRESIDENT   5000     10     10 ACCOUNTING     NEW YORK
  7844 TURNER     SALESMAN    1500     30     30 SALES          CHICAGO
  7876 ADAMS      CLERK       1100     20     20 RESEARCH       DALLAS
  7900 JAMES      CLERK        950     30     30 SALES          CHICAGO
  7902 FORD       ANALYST     3000     20     20 RESEARCH       DALLAS
  7934 MILLER     CLERK       1300     10     10 ACCOUNTING     NEW YORK
                                              40 OPERATIONS     BOSTON

15 rows selected.

ii. LEFT OUTER JOIN :
---------------------

  -> In this joins, first it displays matching records from table1, table2 and un-matched records from 
     left side of the table on JOIN condition.
  

    Select Empno , Ename, Job, Sal, Emp.Deptno, 
				Dept.Deptno, Dname, Loc
					    from emp, Dept
						where emp.deptno=dept.deptno(+);

 EMPNO ENAME      JOB          SAL DEPTNO DEPTNO DNAME          LOC
------ ---------- --------- ------ ------ ------ -------------- -------------
  7934 MILLER     CLERK       1300     10     10 ACCOUNTING     NEW YORK
  7839 KING       PRESIDENT   5000     10     10 ACCOUNTING     NEW YORK
  7782 CLARK      MANAGER     2450     10     10 ACCOUNTING     NEW YORK
  7902 FORD       ANALYST     3000     20     20 RESEARCH       DALLAS
  7876 ADAMS      CLERK       1100     20     20 RESEARCH       DALLAS
  7788 SCOTT      ANALYST     3000     20     20 RESEARCH       DALLAS
  7566 JONES      MANAGER     2975     20     20 RESEARCH       DALLAS
  7369 SMITH      CLERK        800     20     20 RESEARCH       DALLAS
  7900 JAMES      CLERK        950     30     30 SALES          CHICAGO
  7844 TURNER     SALESMAN    1500     30     30 SALES          CHICAGO
  7698 BLAKE      MANAGER     2850     30     30 SALES          CHICAGO
  7654 MARTIN     SALESMAN    1250     30     30 SALES          CHICAGO
  7521 WARD       SALESMAN    1250     30     30 SALES          CHICAGO
  7499 ALLEN      SALESMAN    1600     30     30 SALES          CHICAGO

14 rows selected.

iii. FULL OUTER JOIN :
----------------------


  -> In this joins, it displays matching records from table1, table2 and un-matched records from both tables


    Select Empno , Ename, Job, Sal, Emp.Deptno, 
				Dept.Deptno, Dname, Loc
					    from emp, Dept
						where emp.deptno(+)=dept.deptno(+);

       full outer join = right outer join + left outer join

UNION :
-------

  -> It is one of the oracle SET operator

  -> UNION operator main functionality it displays matching records from table1, table2 at one time and            un-matched records from both tables

A = { 1, 2, 4, 5}

B = { 1, 3, 5 6 }

A u B  ={ 1, 2, 3, 4, 5 , 6 }

	select Empno , Ename, Job, Sal, Emp.Deptno, 
				Dept.Deptno, Dname, Loc
					    from emp, Dept
						where emp.deptno=dept.deptno(+)
			union
	select Empno , Ename, Job, Sal, Emp.Deptno, 
				Dept.Deptno, Dname, Loc
					    from emp, Dept
						where emp.deptno(+)=dept.deptno;

 EMPNO ENAME      JOB          SAL DEPTNO DEPTNO DNAME          LOC
------ ---------- --------- ------ ------ ------ -------------- -------------
  7369 SMITH      CLERK        800     20     20 RESEARCH       DALLAS
  7499 ALLEN      SALESMAN    1600     30     30 SALES          CHICAGO
  7521 WARD       SALESMAN    1250     30     30 SALES          CHICAGO
  7566 JONES      MANAGER     2975     20     20 RESEARCH       DALLAS
  7654 MARTIN     SALESMAN    1250     30     30 SALES          CHICAGO
  7698 BLAKE      MANAGER     2850     30     30 SALES          CHICAGO
  7782 CLARK      MANAGER     2450     10     10 ACCOUNTING     NEW YORK
  7788 SCOTT      ANALYST     3000     20     20 RESEARCH       DALLAS
  7839 KING       PRESIDENT   5000     10     10 ACCOUNTING     NEW YORK
  7844 TURNER     SALESMAN    1500     30     30 SALES          CHICAGO
  7876 ADAMS      CLERK       1100     20     20 RESEARCH       DALLAS
  7900 JAMES      CLERK        950     30     30 SALES          CHICAGO
  7902 FORD       ANALYST     3000     20     20 RESEARCH       DALLAS
  7934 MILLER     CLERK       1300     10     10 ACCOUNTING     NEW YORK
                                              40 OPERATIONS     BOSTON

15 rows selected.

V. SELF JOIN :
--------------

   -> To Join the tables itself is called as SELF-JOIN

   -> To write self join queries, table aliases are mandatory

Table Aliase :
--------------

  -> Aliase name is given to next to table name is called as table alaise

  -> by using Table Alaises to improves the performance and to reduce Complexity of the table name
		
	ex: Employee_master_table emt,  Employee_Transaction_Table ett, emp e, dept d, etc.,

  -> to write self join queries, table should be contains self relation / data

Ex:-

  -- waq to display Superiors and their Sub-Ordinates

EMP M					EMP E
EMPNO	ENAME	MGR			EMPNO	ENAME	MGR
7369	SMITH	7902			7369	SMITH	7902
7499	ALLEN	7698			7499	ALLEN	7698
7566	JONES	7839			7566	JONES	7839
7698	BLAKE	7839			7698	BLAKE	7839
7839	KING				7839	KING
7902	FORD	7566			7902	FORD	7566
7788	SCOTT	7566			7788	SCOTT	7566

		
		SELECT M.ENAME as Superiors, E.ENAME as Sub_ordinates FROM EMP M, EMP E
						WHERE M.EMPNO = E.MGR;
							 
Superiors	Sub_ordinates
JONES		FORD
JONES		SCOTT
BLAKE		ALLEN
KING		JONES
KING		BLAKE
FORD		SMITH

-- waq to display who who are getting morethan their bosses salaries


  select e.ename as employ_name, e.sal as employ_sal,
			m.ename as boss_ename, m.sal as boss_sal
							from emp m, emp e
							   where m.empno = e.mgr
								      and
								 e.sal > m.sal;

EMPLOY_NAM EMPLOY_SAL BOSS_ENAME BOSS_SAL
---------- ---------- ---------- --------
SCOTT            3000 JONES          2975
FORD             3000 JONES          2975

-- waq to display who are joined before joining of their bosses

 select e.ename as employee_name, e.hiredate as doj,
			m.ename as boss_name, m.hiredate as boss_doj
					from emp m, emp e
					      where m.empno = e.mgr
							 and
						    e.hiredate < m.hiredate;

EMPLOYEE_N DOJ       BOSS_NAME  BOSS_DOJ
---------- --------- ---------- ---------
SMITH      17-DEC-80 FORD       03-DEC-81
ALLEN      20-FEB-81 BLAKE      01-MAY-81
WARD       22-FEB-81 BLAKE      01-MAY-81
JONES      02-APR-81 KING       17-NOV-81
BLAKE      01-MAY-81 KING       17-NOV-81
CLARK      09-JUN-81 KING       17-NOV-81

6 rows selected.

ORACLE 9i Joins :
-----------------

  -> Oralce 9i joins are also called as ANSI joins

  -> Oracle 9i supports 8 types of joins

i. Natural Join

ii. Join with USING

iii. Join with ON

iv. Inner Join


v. Right Outer Join

vi. Left Outer Join

vii. Full Outer Join

viii. Cross Join


** first i to iv all are returns equi join outputs

Natural Join :
--------------

  -> to write natural joins, joining tables should be contain atleast one similar column otherwise it returns      cross join output.

ex:    select empno, ename, job, sal, deptno, dname, loc 
					from emp natural join dept;

 EMPNO ENAME      JOB          SAL DEPTNO DNAME          LOC
------ ---------- --------- ------ ------ -------------- -------------
  7369 SMITH      CLERK        800     20 RESEARCH       DALLAS
  7499 ALLEN      SALESMAN    1600     30 SALES          CHICAGO
  7521 WARD       SALESMAN    1250     30 SALES          CHICAGO
  7566 JONES      MANAGER     2975     20 RESEARCH       DALLAS
  7654 MARTIN     SALESMAN    1250     30 SALES          CHICAGO
  7698 BLAKE      MANAGER     2850     30 SALES          CHICAGO
  7782 CLARK      MANAGER     2450     10 ACCOUNTING     NEW YORK
  7788 SCOTT      ANALYST     3000     20 RESEARCH       DALLAS
  7839 KING       PRESIDENT   5000     10 ACCOUNTING     NEW YORK
  7844 TURNER     SALESMAN    1500     30 SALES          CHICAGO
  7876 ADAMS      CLERK       1100     20 RESEARCH       DALLAS
  7900 JAMES      CLERK        950     30 SALES          CHICAGO
  7902 FORD       ANALYST     3000     20 RESEARCH       DALLAS
  7934 MILLER     CLERK       1300     10 ACCOUNTING     NEW YORK

14 rows selected.


ii. JOIN with USING :
---------------------

  -> to write join with using JOINING tables should be containt atleast one similar column name, otherwise
     it returns cross join output.

SQL>   select * From Emp Join Dept using( Deptno );

DEPTNO  EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DNAME          LOC
------ ------ ---------- --------- ------ --------- ------ ------ -------------- -------------
    20   7369 SMITH      CLERK       7902 17-DEC-80    800        RESEARCH       DALLAS
    30   7499 ALLEN      SALESMAN    7698 20-FEB-81   1600    300 SALES          CHICAGO
    30   7521 WARD       SALESMAN    7698 22-FEB-81   1250    500 SALES          CHICAGO
    20   7566 JONES      MANAGER     7839 02-APR-81   2975        RESEARCH       DALLAS
    30   7654 MARTIN     SALESMAN    7698 28-SEP-81   1250   1400 SALES          CHICAGO
    30   7698 BLAKE      MANAGER     7839 01-MAY-81   2850        SALES          CHICAGO
    10   7782 CLARK      MANAGER     7839 09-JUN-81   2450        ACCOUNTING     NEW YORK
    20   7788 SCOTT      ANALYST     7566 09-DEC-82   3000        RESEARCH       DALLAS
    10   7839 KING       PRESIDENT        17-NOV-81   5000        ACCOUNTING     NEW YORK
    30   7844 TURNER     SALESMAN    7698 08-SEP-81   1500      0 SALES          CHICAGO
    20   7876 ADAMS      CLERK       7788 12-JAN-83   1100        RESEARCH       DALLAS
    30   7900 JAMES      CLERK       7698 03-DEC-81    950        SALES          CHICAGO
    20   7902 FORD       ANALYST     7566 03-DEC-81   3000        RESEARCH       DALLAS
    10   7934 MILLER     CLERK       7782 23-JAN-82   1300        ACCOUNTING     NEW YORK

14 rows selected.


iii. JOIN with ON :
-------------------

SQL> select empno, ename, sal, job, emp.deptno, dept.deptno, dname, loc  
				from emp join dept ON ( Emp.Deptno = Dept.Deptno );

 EMPNO ENAME         SAL JOB       DEPTNO DEPTNO DNAME          LOC
------ ---------- ------ --------- ------ ------ -------------- -------------
  7369 SMITH         800 CLERK         20     20 RESEARCH       DALLAS
  7499 ALLEN        1600 SALESMAN      30     30 SALES          CHICAGO
  7521 WARD         1250 SALESMAN      30     30 SALES          CHICAGO
  7566 JONES        2975 MANAGER       20     20 RESEARCH       DALLAS
  7654 MARTIN       1250 SALESMAN      30     30 SALES          CHICAGO
  7698 BLAKE        2850 MANAGER       30     30 SALES          CHICAGO
  7782 CLARK        2450 MANAGER       10     10 ACCOUNTING     NEW YORK
  7788 SCOTT        3000 ANALYST       20     20 RESEARCH       DALLAS
  7839 KING         5000 PRESIDENT     10     10 ACCOUNTING     NEW YORK
  7844 TURNER       1500 SALESMAN      30     30 SALES          CHICAGO
  7876 ADAMS        1100 CLERK         20     20 RESEARCH       DALLAS
  7900 JAMES         950 CLERK         30     30 SALES          CHICAGO
  7902 FORD         3000 ANALYST       20     20 RESEARCH       DALLAS
  7934 MILLER       1300 CLERK         10     10 ACCOUNTING     NEW YORK

14 rows selected.

iv. INNER JOIN :
----------------

SQL> select empno, ename, sal, job, emp.deptno, dept.deptno, dname, loc  
				from emp inner join dept ON ( Emp.Deptno = Dept.Deptno );

 EMPNO ENAME         SAL JOB       DEPTNO DEPTNO DNAME          LOC
------ ---------- ------ --------- ------ ------ -------------- -------------
  7369 SMITH         800 CLERK         20     20 RESEARCH       DALLAS
  7499 ALLEN        1600 SALESMAN      30     30 SALES          CHICAGO
  7521 WARD         1250 SALESMAN      30     30 SALES          CHICAGO
  7566 JONES        2975 MANAGER       20     20 RESEARCH       DALLAS
  7654 MARTIN       1250 SALESMAN      30     30 SALES          CHICAGO
  7698 BLAKE        2850 MANAGER       30     30 SALES          CHICAGO
  7782 CLARK        2450 MANAGER       10     10 ACCOUNTING     NEW YORK
  7788 SCOTT        3000 ANALYST       20     20 RESEARCH       DALLAS
  7839 KING         5000 PRESIDENT     10     10 ACCOUNTING     NEW YORK
  7844 TURNER       1500 SALESMAN      30     30 SALES          CHICAGO
  7876 ADAMS        1100 CLERK         20     20 RESEARCH       DALLAS
  7900 JAMES         950 CLERK         30     30 SALES          CHICAGO
  7902 FORD         3000 ANALYST       20     20 RESEARCH       DALLAS
  7934 MILLER       1300 CLERK         10     10 ACCOUNTING     NEW YORK

14 rows selected.

v. Right Outer Join :
---------------------

  -> In this joins, it displays matching records from table1, table2 and un-matched records from right side          table

         select Empno, Ename, Job, Sal, Emp.Deptno, Dept.Deptno, Dname, Loc
						from Emp right outer join dept 
								ON ( Emp.Deptno = Dept.Deptno );

 EMPNO ENAME      JOB          SAL DEPTNO DEPTNO DNAME          LOC
------ ---------- --------- ------ ------ ------ -------------- -------------
  7369 SMITH      CLERK        800     20     20 RESEARCH       DALLAS
  7499 ALLEN      SALESMAN    1600     30     30 SALES          CHICAGO
  7521 WARD       SALESMAN    1250     30     30 SALES          CHICAGO
  7566 JONES      MANAGER     2975     20     20 RESEARCH       DALLAS
  7654 MARTIN     SALESMAN    1250     30     30 SALES          CHICAGO
  7698 BLAKE      MANAGER     2850     30     30 SALES          CHICAGO
  7782 CLARK      MANAGER     2450     10     10 ACCOUNTING     NEW YORK
  7788 SCOTT      ANALYST     3000     20     20 RESEARCH       DALLAS
  7839 KING       PRESIDENT   5000     10     10 ACCOUNTING     NEW YORK
  7844 TURNER     SALESMAN    1500     30     30 SALES          CHICAGO
  7876 ADAMS      CLERK       1100     20     20 RESEARCH       DALLAS
  7900 JAMES      CLERK        950     30     30 SALES          CHICAGO
  7902 FORD       ANALYST     3000     20     20 RESEARCH       DALLAS
  7934 MILLER     CLERK       1300     10     10 ACCOUNTING     NEW YORK
                                              40 OPERATIONS     BOSTON

15 rows selected.

LEFT OUTER JOIN :
-----------------

  -> In this joins, it displays matching records from table1, table2 and un-matched records from LEFT side          table

   select Empno, Ename, Job, Sal, Emp.Deptno, Dept.Deptno, Dname, Loc
						from Emp left outer join dept
							ON ( Emp.Deptno = Dept.Deptno );


 EMPNO ENAME      JOB          SAL DEPTNO DEPTNO DNAME          LOC
------ ---------- --------- ------ ------ ------ -------------- -------------
  7934 MILLER     CLERK       1300     10     10 ACCOUNTING     NEW YORK
  7839 KING       PRESIDENT   5000     10     10 ACCOUNTING     NEW YORK
  7782 CLARK      MANAGER     2450     10     10 ACCOUNTING     NEW YORK
  7902 FORD       ANALYST     3000     20     20 RESEARCH       DALLAS
  7876 ADAMS      CLERK       1100     20     20 RESEARCH       DALLAS
  7788 SCOTT      ANALYST     3000     20     20 RESEARCH       DALLAS
  7566 JONES      MANAGER     2975     20     20 RESEARCH       DALLAS
  7369 SMITH      CLERK        800     20     20 RESEARCH       DALLAS
  7900 JAMES      CLERK        950     30     30 SALES          CHICAGO
  7844 TURNER     SALESMAN    1500     30     30 SALES          CHICAGO
  7698 BLAKE      MANAGER     2850     30     30 SALES          CHICAGO
  7654 MARTIN     SALESMAN    1250     30     30 SALES          CHICAGO
  7521 WARD       SALESMAN    1250     30     30 SALES          CHICAGO
  7499 ALLEN      SALESMAN    1600     30     30 SALES          CHICAGO

14 rows selected.


FULL OUTER JOIN :
-----------------

  -> It displays matching records from table1 , table2 and un-matched records from both tables


 select Empno, Ename, Job, Sal, Emp.Deptno, Dept.Deptno, Dname, Loc
						from Emp full outer join dept
							ON ( Emp.Deptno = Dept.Deptno );

 EMPNO ENAME      JOB          SAL DEPTNO DEPTNO DNAME          LOC
------ ---------- --------- ------ ------ ------ -------------- -------------
  7369 SMITH      CLERK        800     20     20 RESEARCH       DALLAS
  7499 ALLEN      SALESMAN    1600     30     30 SALES          CHICAGO
  7521 WARD       SALESMAN    1250     30     30 SALES          CHICAGO
  7566 JONES      MANAGER     2975     20     20 RESEARCH       DALLAS
  7654 MARTIN     SALESMAN    1250     30     30 SALES          CHICAGO
  7698 BLAKE      MANAGER     2850     30     30 SALES          CHICAGO
  7782 CLARK      MANAGER     2450     10     10 ACCOUNTING     NEW YORK
  7788 SCOTT      ANALYST     3000     20     20 RESEARCH       DALLAS
  7839 KING       PRESIDENT   5000     10     10 ACCOUNTING     NEW YORK
  7844 TURNER     SALESMAN    1500     30     30 SALES          CHICAGO
  7876 ADAMS      CLERK       1100     20     20 RESEARCH       DALLAS
  7900 JAMES      CLERK        950     30     30 SALES          CHICAGO
  7902 FORD       ANALYST     3000     20     20 RESEARCH       DALLAS
  7934 MILLER     CLERK       1300     10     10 ACCOUNTING     NEW YORK
                                              40 OPERATIONS     BOSTON

15 rows selected.


CROSS JOIN :
------------

  -> it displays no.of records in table1 x no.of records from table2

           select * from emp cross join dept;


Example:
--------

emp:  empno, ename, sal, deptno

dept: deptno, dname, loc

shift: shiftid, shiftname

task : task id, task name

trans : tno, tdate, empno, deptno, shiftid, taskid , status

-- waq to display employee no, employee name, salary, deptno, dname, location, shift ids, shiftname,
   task id, task name and which employees are completed task


    select e.empno. e.ename, e.sal, e.deptno, d.dname, d.loc,
                s.shiftid, s.shiftname, t.taskid, t.taskname, tr.status
					from emp e, dept d, shift s,
					     task t, tran tr
					where e.deptno = d.deptno
						     and
					      s.shiftid= tr.shiftid
						     and
					      d.deptno = tr.deptno
						      and
					      t.taskid = tr.taskid
						       and
						  tr.status='y';


IV. DCL ( Data Control Language ) :
-----------------------------------

  -> by using this control lang. commands we can control data in between users

  -> there are two types of DCL commands

        i. grant 

       ii. revoke

i. grant :
----------

  -> this command is used to grant the permission or previliges on DB object to users

syn:-

   grant <permission>/<priviliges> ON <db_object> TO <user1> [, <user2>,...];


ii. revoke :
------------

  -> this command used to getback the given permissions

syn:-

   revoke <permission>/<priviliges> ON <DB_OBJECT> from <user1> [, <user2>,...];


** priviliges / permissions two types
   
        i. Object Priviliges

       ii. System Priviliges

i. Object Priviliges :
----------------------

  -> to give the permissions on db objects is called as Object Priviliges

          ex: SELECT, INSERT, UPDATE, DELETE, etc.,

ii. System Priviliges :
-----------------------

  -> These priviliges are provided by Oracle

         ex:  connect, resource, dba, etc.,

Example :
---------

  -- to execute these commands we must contain two users


** create a new user

connect to dba user :
---------------------

Create user my_user identified by lion;

grant connect, resource to my_user;


my_user: select * from emp;
 
            error: table or view doesn't exist

ora8pm: grant select on emp to my_user;

my_user: select * from ora8pm.emp;

my_user: update ora8pm.emp set sal = sal + 100;

	    error: in-sufficient priviliges

ora8pm: grant update on emp to my_user;

my_user: update ora8pm.emp set sal = sal + 100;

	    now above query executed.

ora8pm: grant all on emp to my_user;

 
          ** All permissions are granted to my_user;

REVOKE :
--------

ora8pm: revoke select on emp from my_user;

my_user: select * from ora8pm.emp;

           error: in-sufficient priviliges


** to see the granted permissions

       select * from user_tab_privs_made;          -- we can execute on ORA8PM user

** to see the received permissions

       select * from user_tab_privs_recd;         -- we can execute in MY_USER user

V. TCL commands :
-----------------

    -> TCL commands are used to control DML transactions

    -> there are 3 types of TCL commands

         i. commit

        ii. savepoint

       iii. rollback

i. commit :
-----------

  -> this command is used to save DML transactions into DB permanently

  -> there are two types commits

       a. Explicit commit 

		-> it is performed by USER explicitely
                     
                     ex: DML commands

       b. Implicit commit

                -> it is performed by oracle automatically

                    ex: DDL commands

ii. Savepoint :
---------------

 -> used to create a book mark

syn:-

  savepoint <savepoint_name>;

iii. ROLLBACK :
---------------
  
  -> used to undo DML transactions

  -> After commit whatever DML transactions are completed all are undo.

Example :
---------

sql> select * from emp;

       -- 14 rows selected

sql> savepoint s1;

sql> delete from emp where empno=7788;

sql> savepoint s2;

sql> insert into emp values( 1001, 'aaa', 'clerk', 7839, sysdate, 6000, 100, 10 );

sql> savepoint s3;

sql> update emp set sal = sal + 100;

sql> select * from emp;

     -- 14 rows seleted

sql> rollback to s2;     

       -- upto savepoint s2(s3 & s2 ) all transactions are undo.

sql> select * from emp;

      -- 13 rows selected

sql> commit;

     note: once commit is executed whatever Savepoints are there in LIVE all are destroyed and
           inside the savepoint transactions are saved into db permanently

ex:-

sql> insert
     update
     commit
     insert
     delete
     rollback;

** in above example DELETE & INSERT transactions are undo


sql> insert
     create
     update
     insert
     commit
     insert
     create
     update
     rollback;

** in above example only UPDATE command undo

OBJECT TECHNOLOGY :
-------------------

  -> From oracle 8.0 onwards OOPs features are supported

what is a Object ?

  -> Object is a collection of elements of different datatypes and stored at centrally one 
     memory location

  -> Objects are supports methods( functions )

  -> Objects are re-usable components

  -> Objects doesn't hold any data it represents only structure

  -> All created Objects are stored in USER_TYPES( system table )

syn:-

 Create or replace type <object_name> AS  Object ( ele1 datatype(size),
						   ele2 datatype(size),
                                                   ...................
						 );

Ex:-

adminid  admin name  addr1   addr2   addr3   addr4,......

empid   empname  addr1, addr2, addr3, addr4,.......

cid  cname addr1,  addr2,  addr3, addr4,......


ex:-

  -- create a object with address

Create or replace type addr_obj as object
( Hno varchar(10),
  Street varchar(10),
  City varchar(10),
  pincode number(6)
);

SQL> desc addr_obj;
 Name                                                  Null?    Type
 ----------------------------------------------------- -------- ------------------------------------
 HNO                                                            VARCHAR2(10)
 STREET                                                         VARCHAR2(10)
 CITY                                                           VARCHAR2(10)
 PINCODE                                                        NUMBER(6)


Create a db table using ADDR_OBJ Object :
-----------------------------------------

Create table admin( Admin_id varchar(10),
		    Admin_name varchar(10),
		    Address Addr_obj,
		    Mobileno Number(10)
                 );

SQL> desc admin;
 Name                                                  Null?    Type
 ----------------------------------------------------- -------- ------------------------------------
 ADMIN_ID                                                       VARCHAR2(10)
 ADMIN_NAME                                                     VARCHAR2(10)
 ADDRESS                                                        ADDR_OBJ
 MOBILENO                                                       NUMBER(10)

Insert data into object table :
-------------------------------

 Insert into admin values ( 'A1', 'King', Addr_obj( '201', 'ameerpet', 'sec', 500016), 9000994005);


SQL> SELECT * FROM ADMIN;

ADMIN_ID   ADMIN_NAME
---------- ----------
ADDRESS(HNO, STREET, CITY, PINCODE)
----------------------------------------------------------------------------------------------------
  MOBILENO
----------
A1         King
ADDR_OBJ('201', 'ameerpet', 'sec', 500016)
9000994005


to update object columns data :
-------------------------------

sql>  Update admin a set a.address.city='hyd' where a.admin_id='A1';

SQL> select * from admin;

ADMIN_ID   ADMIN_NAME
---------- ----------
ADDRESS(HNO, STREET, CITY, PINCODE)
----------------------------------------------------------------------------------------------------
  MOBILENO
----------
A1         King
ADDR_OBJ('201', 'ameerpet', 'hyd', 500016)
9000994005
 
SELECTING OBJECT COLUMNS :
--------------------------

SQL>  Select a.admin_id, a.admin_name, a.address.street as street, a.address.city as city from admin a;

ADMIN_ID   ADMIN_NAME STREET     CITY
---------- ---------- ---------- ----------
A1         King       ameerpet   hyd

Objects are re-usable components :
----------------------------------

  -- create a student table with student id, student name, present address, permanent address, mobileno,...

Table creation:
---------------

Create table student
( std_id varchar(10),
  std_name varchar(10),
  pres_addr addr_obj,
  perm_addr addr_obj,
  mobileno number(10)
);

** to see the created  object names

     select * from user_types;

** Dropping objects

    Drop type <object_name>;

Ex: Drop type addr_obj;


note: to drop objects first Dependent object tables should be drop

DB OBJECTS :
------------


 -> A Component automatically registered in system software is called as DB OBJECTS

          ex: Tables, Views, Indexes, Sequences, synonyms, roles, etc.,

Table :
-------

  -> it is a collection of information stored in rows and columns format

  -> maximum 1000 columns are allowed and un-limited records per a table

  -> It is common db object any relational databases

VIEWS :
-------

  -> View is one of the Virtual DB OBject

  -> Views are created based on SELECT statement output.

  -> Views are based on BASE TABLE

  -> Views doesn't hold any information and it represents only structure

  -> Views provides Security on DB Table Names

  -> By using Views to hold multiple tables information into single table

  -> All created view names are stored in USER_VIEWS( pre-defined table )

Syn:-

Create or replace view <view_name>
AS
<Select Statement>;


-> Basically views are 4 types

i. Simple views

ii. Complex Views

iii. Force Views

iv. Materialized Views

i. Simple views :
-----------------

  -> These views are created by select statment doesn't contain Join Conditions / Arithmatic Expressions /           Group by Clause / Etc.,

  -> To create the views by using single table is called as Simple Views

ex:-

  Create or replace view my_view
  As
  Select * from Emp;


SQL> desc my_view;
 Name                                                  Null?    Type
 ----------------------------------------------------- -------- ------------------------------------
 EMPNO                                                 NOT NULL NUMBER(4)
 ENAME                                                          VARCHAR2(10)
 JOB                                                            VARCHAR2(9)
 MGR                                                            NUMBER(4)
 HIREDATE                                                       DATE
 SAL                                                            NUMBER(7,2)
 COMM                                                           NUMBER(7,2)
 DEPTNO                                                         NUMBER(2)

SQL> select * from my_view;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 17-DEC-80    900            20
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1700    300     30
  7521 WARD       SALESMAN    7698 22-FEB-81   1350    500     30
  7566 JONES      MANAGER     7839 02-APR-81   3075            20
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1350   1400     30
  7698 BLAKE      MANAGER     7839 01-MAY-81   2950            30
  7782 CLARK      MANAGER     7839 09-JUN-81   2550            10
  7788 SCOTT      ANALYST     7566 09-DEC-82   3100            20
  7839 KING       PRESIDENT        17-NOV-81   5100            10
  7844 TURNER     SALESMAN    7698 08-SEP-81   1600      0     30
  7876 ADAMS      CLERK       7788 12-JAN-83   1200            20
  7900 JAMES      CLERK       7698 03-DEC-81   1050            30
  7902 FORD       ANALYST     7566 03-DEC-81   3100            20
  7934 MILLER     CLERK       7782 23-JAN-82   1400            10

14 rows selected.

 
Inserting data into views :
---------------------------

SQL>  Insert Into my_view values ( 1001, 'AAA', 'clerk', 7839, sysdate, 5000, 100, 20 );

1 row created.

SQL> select * from my_view;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 17-DEC-80    900            20
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1700    300     30
  7521 WARD       SALESMAN    7698 22-FEB-81   1350    500     30
  7566 JONES      MANAGER     7839 02-APR-81   3075            20
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1350   1400     30
  7698 BLAKE      MANAGER     7839 01-MAY-81   2950            30
  7782 CLARK      MANAGER     7839 09-JUN-81   2550            10
  7788 SCOTT      ANALYST     7566 09-DEC-82   3100            20
  7839 KING       PRESIDENT        17-NOV-81   5100            10
  7844 TURNER     SALESMAN    7698 08-SEP-81   1600      0     30
  7876 ADAMS      CLERK       7788 12-JAN-83   1200            20
  7900 JAMES      CLERK       7698 03-DEC-81   1050            30
  7902 FORD       ANALYST     7566 03-DEC-81   3100            20
  7934 MILLER     CLERK       7782 23-JAN-82   1400            10
  1001 AAA        clerk       7839 07-FEB-22   5000    100     20

15 rows selected.

SQL> select * from emp;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 17-DEC-80    900            20
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1700    300     30
  7521 WARD       SALESMAN    7698 22-FEB-81   1350    500     30
  7566 JONES      MANAGER     7839 02-APR-81   3075            20
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1350   1400     30
  7698 BLAKE      MANAGER     7839 01-MAY-81   2950            30
  7782 CLARK      MANAGER     7839 09-JUN-81   2550            10
  7788 SCOTT      ANALYST     7566 09-DEC-82   3100            20
  7839 KING       PRESIDENT        17-NOV-81   5100            10
  7844 TURNER     SALESMAN    7698 08-SEP-81   1600      0     30
  7876 ADAMS      CLERK       7788 12-JAN-83   1200            20
  7900 JAMES      CLERK       7698 03-DEC-81   1050            30
  7902 FORD       ANALYST     7566 03-DEC-81   3100            20
  7934 MILLER     CLERK       7782 23-JAN-82   1400            10
  1001 AAA        clerk       7839 07-FEB-22   5000    100     20

15 rows selected.

note: to perform any DML commands on views that are reflected on base table and vice versa


ex2:-

Create or replace view dept10
As
select empno, ename, sal, deptno from emp where deptno=10;

View created.

SQL> select * from dept10;

 EMPNO ENAME         SAL DEPTNO
------ ---------- ------ ------
  7782 CLARK        2550     10
  7839 KING         5100     10
  7934 MILLER       1400     10

Insert command :
----------------

SQL>  Insert into dept10 values ( 1002, 'BBB', 2000, 20 );

1 row created.

SQL> select * from dept10;

 EMPNO ENAME         SAL DEPTNO
------ ---------- ------ ------
  7782 CLARK        2550     10
  7839 KING         5100     10
  7934 MILLER       1400     10

SQL> select * from emp;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 17-DEC-80    900            20
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1700    300     30
  7521 WARD       SALESMAN    7698 22-FEB-81   1350    500     30
  7566 JONES      MANAGER     7839 02-APR-81   3075            20
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1350   1400     30
  7698 BLAKE      MANAGER     7839 01-MAY-81   2950            30
  7782 CLARK      MANAGER     7839 09-JUN-81   2550            10
  7788 SCOTT      ANALYST     7566 09-DEC-82   3100            20
  7839 KING       PRESIDENT        17-NOV-81   5100            10
  7844 TURNER     SALESMAN    7698 08-SEP-81   1600      0     30
  7876 ADAMS      CLERK       7788 12-JAN-83   1200            20
  7900 JAMES      CLERK       7698 03-DEC-81   1050            30
  7902 FORD       ANALYST     7566 03-DEC-81   3100            20
  7934 MILLER     CLERK       7782 23-JAN-82   1400            10
  1001 AAA        clerk       7839 07-FEB-22   5000    100     20
  1002 BBB                                     2000            20

16 rows selected.


View constraints :
------------------

WITH CHECK OPTION:
------------------

  -> if inserting data satisfies view condition then record is inserted into view and base table otherwise
     it returns constraint voilated error message

Ex:-

Create or replace view dept10_view
As
select empno, ename, sal, deptno from emp where deptno=10 WITH CHECK OPTION;

Checking:
---------

SQL> insert into dept10_view values ( 1003, 'CCC', 4000, 20 );
insert into dept10_view values ( 1003, 'CCC', 4000, 20 )
            *
ERROR at line 1:
ORA-01402: view WITH CHECK OPTION where-clause violation


SQL> insert into dept10_view values ( 1003, 'CCC', 4000, 10 );

1 row created.

SQL> SELECT * FROM DEPT10_VIEW;

 EMPNO ENAME         SAL DEPTNO
------ ---------- ------ ------
  7782 CLARK        2550     10
  7839 KING         5100     10
  7934 MILLER       1400     10
  1003 CCC          4000     10
	
READ ONLY VIEWS :
-----------------

 -> These views are only for Reading purpose

 -> On Read only views DML commands are not supported

 -> Only SELECT & DESC commands are valid

ex:-

Create or replace view read_view
As
select * from emp with read only;

SQL> select * from read_view;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 17-DEC-80    900            20
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1700    300     30
  7521 WARD       SALESMAN    7698 22-FEB-81   1350    500     30
  7566 JONES      MANAGER     7839 02-APR-81   3075            20
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1350   1400     30
  7698 BLAKE      MANAGER     7839 01-MAY-81   2950            30
  7782 CLARK      MANAGER     7839 09-JUN-81   2550            10
  7788 SCOTT      ANALYST     7566 09-DEC-82   3100            20
  7839 KING       PRESIDENT        17-NOV-81   5100            10
  7844 TURNER     SALESMAN    7698 08-SEP-81   1600      0     30
  7876 ADAMS      CLERK       7788 12-JAN-83   1200            20
  7900 JAMES      CLERK       7698 03-DEC-81   1050            30
  7902 FORD       ANALYST     7566 03-DEC-81   3100            20
  7934 MILLER     CLERK       7782 23-JAN-82   1400            10
  1001 AAA        clerk       7839 07-FEB-22   5000    100     20
  1002 BBB                                     2000            20
  1003 CCC                                     4000            10

17 rows selected.

SQL> update read_view set sal = sal + 100;
update read_view set sal = sal + 100
                     *
ERROR at line 1:
ORA-42399: cannot perform a DML operation on a read-only view

ii. COMPLEX VIEWS :
-------------------

  -> these views are created by select statement  contains join conditions, group by clause , having clause,      etc.,

  -> On complex views DML commands are not supported

  -> Only SELECT & DESC commands are valid

  -> by using complex views we can hold multiple tables information into single table

ex:-

Create or replace view EMPDEPT
AS
Select e.empno, e.ename, e.sal, d.deptno, d.dname, d.loc
					From Emp e, Dept d
						 where e.deptno = d.deptno;

SQL> select * from empdept;

 EMPNO ENAME         SAL DEPTNO DNAME          LOC
------ ---------- ------ ------ -------------- -------------
  7369 SMITH         900     20 RESEARCH       DALLAS
  7499 ALLEN        1700     30 SALES          CHICAGO
  7521 WARD         1350     30 SALES          CHICAGO
  7566 JONES        3075     20 RESEARCH       DALLAS
  7654 MARTIN       1350     30 SALES          CHICAGO
  7698 BLAKE        2950     30 SALES          CHICAGO
  7782 CLARK        2550     10 ACCOUNTING     NEW YORK

Inserting data EMPDEPT:
-----------------------  

 Insert into EmpDept values ( 1004, 'DDDD', 4000, 10, 'ACCOUNTING', 'NEW YORK');
 
SQL> Insert into EmpDept values ( 1004, 'DDDD', 4000, 10, 'ACCOUNTING', 'NEW YORK');
Insert into EmpDept values ( 1004, 'DDDD', 4000, 10, 'ACCOUNTING', 'NEW YORK')
*
ERROR at line 1:
ORA-01779: cannot modify a column which maps to a non key-preserved table


Note: On complex views DML commands are not supported, but we can perform  DML operations on BASETABLEs

ex2:-

  -- complex views using Table Alaise

       Create or replace view CV1 
       As
       Select deptno, min(sal) as minsal, Max(sal) as maxsal, sum(sal)  as sumsal from emp
					group by Deptno;

View created.

SQL> desc cv1;
 Name                                                  Null?    Type
 ----------------------------------------------------- -------- ------------------------------------
 DEPTNO                                                         NUMBER(2)
 MINSAL                                                         NUMBER
 MAXSAL                                                         NUMBER
 SUMSAL                                                         NUMBER

SQL> select * from cv1;

DEPTNO MINSAL MAXSAL SUMSAL
------ ------ ------ ------
    30   1050   2950  10000
    20    900   5000  18375
    10   1400   5100  13050

iii. Force views :
------------------

  -> These views are created without having any BASETABLE

  -> Force views are activated whenever BASE TABLE is created

ex:-

 SQL> create or replace force view cv20 as select *from emp123;

Warning: View created with compilation errors.

SQL> select * from tab;

TNAME                          TABTYPE CLUSTERID
------------------------------ ------- ---------
ADMIN                          TABLE
BONUS                          TABLE
CV1                            VIEW
CV20                           VIEW
DEPT                           TABLE
DEPT10                         VIEW
DEPT10_VIEW                    VIEW
DUMMY                          TABLE
EMP                            TABLE
EMPDEPT                        VIEW
MY_VIEW                        VIEW
READ_VIEW                      VIEW
SALGRADE                       TABLE

13 rows selected.

SQL> desc cv20
ERROR:
ORA-24372: invalid object for describe

IV.Materialized views :
-----------------------

    -> To store the data in views is called as Materialized views

    -> These views are created by DBA

View provides security :
------------------------

ora8pm: grant select on emp to ora7pm;

ora7pm: select * from ora8pm.emp;

note: here no security on username & table name, to provide security on TABLE NAME then create a view on EMP table

ora8pm: create or replace view XYZ as select * from emp;

ora8pm: grant select,update on XYZ To ora7pm;

ora7pm: select * from ora8pm.XYZ;

note: here security provides on TABLE NAME


** to see the created view names

 select * from user_views;

** dropping views

 Drop view <view_name>;

Ex:  Drop view my_view;

** Once drop the view base table is available ?

ans. Yes, base table is available

** Once drop the base table view is available ?

Ans. Once drop the base table VIEWS are available but those views doesn't contain any structure


INDEXES :
---------

  -> Indexes are used to improves the performance while retrieving or manipulating data

  -> by default ORACLE db follows TABLE SCAN method

  -> Indexes are activated whenver Indexed Column is placed on WHERE clause of SELECT statement

  -> Indexes are also activated whenthe tables are manipulated by other users

  -> All created indexes are stored USER_INDEXES( system table )

  -> Basically Indexes are two types

           I. Implicit Index

		-> These indexes are created by oracle automatically

                          ex: PRIMARY KEY, UNIQUE Constraint

          II. Explicit Index 

                -> These are created user Explicitely

                -> There are different types of Explicit Indexes

 a. Normal Indexes :
--------------------

  -> these indexes are created by any db column

syn:-

  Create Index <Index_name> ON <table_name>( col1, col2,.... );

ex:-

SQL>   Create index empno_ind on Emp(Empno);

Index created.

SQL> select * from emp where empno=7934;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7934 MILLER     CLERK       7782 23-JAN-82   1400            10

ii. Composite Indexes :
-----------------------

  -> To create index on morethan one column is called as composite indexes

  -> In Composite Indexes Maximum 32 columns are supported

ex:-

  Create Index comp_ind on Emp( Deptno, Job );

  select * from emp where deptno=10 and job='clerk';

iii. Functional Based Indexes :
-------------------------------
 
  -> these indexes are created by using BUILT-IN FUNCTIONS


ex:-  create index fun_ind on emp( lower(job) );

      select * from emp where job='clerk';


job(index)
---------
clerk
manager
CLERK
ANALYST
MANAGER
president
.
.
1000

  400  -> small case letters

  600  -> upper case letters

select * from emp where job='clerk';


UNIQUE INDEXES :
----------------

  -> these indexes are created on UNIQUE Data columns

ex:-

  Create unique index uni_job_ind on Emp( job );    => Error

  Create unique index uni_empno_ind on Emp( empno ); 


note: Indexes are not created on if any column datatype contains LOB, BLOB, CLOB, RAW, LONG RAW, etc., datatypes

** to see the created indexes names

     select * from user_indexes;

** Dropping Indexes :
---------------------

 Drop Index my_ind;

SEQUENCES :
-----------

  -> Sequences are used to generate sequence of numbers automatically

  -> Sequences are supports only Numarics

  -> Sequences are supports two pseudo columns
    
           i. currval     ii. nextval

SYNONYMS :
----------

  -> Synonym is an another name for a given table name

  -> Synonyms are created on entire table

  -> Synonyms supports DML, SELECT & DESC commands

  -> Synonyms provides High Security

  -> All created synonyms are stored in USER_SYNONYMS( System table )

  -> To perform any DML commands on synonyms that are reflected on BASE TABLE and vice versa

  -> Synonyms are two types

           i. Private Synonym

          ii. Public Synonym

i. Private Synonym:
-------------------

  -> it is created by owner( user )

  -> Private synonyms provides security on TABLE NAMEs only 

syn:-

Create synonym <synonym_name> for <table_name>;

Ex:-

Create synonym my_syn for emp;

SQL> select * from my_syn;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 17-DEC-80    900            20
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1700    300     30
  7521 WARD       SALESMAN    7698 22-FEB-81   1350    500     30
  7566 JONES      MANAGER     7839 02-APR-81   3075            20

Insert command on my_syn :
--------------------------

sql> Insert into my_syn values ( 1001, 'AAA', 'CLERK', 7839, SYSDATE, 5000, 100, 10 );

SQL> select * from my_syn;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 17-DEC-80    900            20
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1700    300     30
  7521 WARD       SALESMAN    7698 22-FEB-81   1350    500     30
  7566 JONES      MANAGER     7839 02-APR-81   3075            20
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1350   1400     30
  7698 BLAKE      MANAGER     7839 01-MAY-81   2950            30
  7782 CLARK      MANAGER     7839 09-JUN-81   2550            10
  7788 SCOTT      ANALYST     7566 09-DEC-82   3100            20
  7839 KING       PRESIDENT        17-NOV-81   5100            10
  7844 TURNER     SALESMAN    7698 08-SEP-81   1600      0     30
  7876 ADAMS      CLERK       7788 12-JAN-83   1200            20
  7900 JAMES      CLERK       7698 03-DEC-81   1050            30
  7902 FORD       ANALYST     7566 03-DEC-81   3100            20
  7934 MILLER     CLERK       7782 23-JAN-82   1400            10
  1001 AAA        CLERK       7839 08-FEB-22   5000    100     10

15 rows selected.

SQL> SELECT * FROM EMP;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 17-DEC-80    900            20
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1700    300     30
  7521 WARD       SALESMAN    7698 22-FEB-81   1350    500     30
  7566 JONES      MANAGER     7839 02-APR-81   3075            20
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1350   1400     30
  7698 BLAKE      MANAGER     7839 01-MAY-81   2950            30
  7782 CLARK      MANAGER     7839 09-JUN-81   2550            10
  7788 SCOTT      ANALYST     7566 09-DEC-82   3100            20
  7839 KING       PRESIDENT        17-NOV-81   5100            10
  7844 TURNER     SALESMAN    7698 08-SEP-81   1600      0     30
  7876 ADAMS      CLERK       7788 12-JAN-83   1200            20
  7900 JAMES      CLERK       7698 03-DEC-81   1050            30
  7902 FORD       ANALYST     7566 03-DEC-81   3100            20
  7934 MILLER     CLERK       7782 23-JAN-82   1400            10
  1001 AAA        CLERK       7839 08-FEB-22   5000    100     10

15 rows selected.
  
Granting private Synonyms :
---------------------------

ora8pm: grant select on my_syn to ora7pm;

ora7pm: select * from ora8pm.my_syn;   

note: here security provides table name only

ora8pm: grant select on my_syn to user1;

ora8pm: grant select on my_syn to user2;

ii. PUBLIC SYNONYMS:
---------------------

  -> these synonyms are created by DBA only

  -> Only One Grant permission all users can access public synonym directly

  -> Public synonyms provides high security on DB Tables

syn:-  

  Create public synonym <synonym_name> for <table_name>;

ex:-

connect to dba user :
---------------------
username: system
password: server

SQL> Create Public Synonym ABC for ora8pm.emp;

Synonym created.

SQL> GRANT select on abc to public;

Grant succeeded.

note: PUBLIC  -> All users


ora7pm: select * from abc;

ora7am: select * from abc;

user1: select * from abc;

note: here security provides on Table Name & USER NAME also

** to see the created synonyms names

       select * from user_synonyms;

** Dropping synonyms 

private synonym: Drop synonym my_syn;          -- user can drop

public synonym:  Drop Public Synonym abc;      -- dba can drop 

ROLES :
-------

  -> It is a collection of different Object Priviliges on different db objects

  -> It is Created by DBA

syn:-

  Create role <role_name>;

Ex:-

Connect to dba user:
--------------------
username: system
password: server

sql> Create role my_role;

Granting permssions to roles :
------------------------------

Grant select, insert on ora8pm.emp to my_role;

Grant select on ora8pm.dept to my_role;

Grant select, update on ora8pm.my_view to my_role;

Grant select on ora8pm.my_syn to my_role;


Granting roles to Users :
-------------------------

Grant my_role to User1;

Grant my_role to User2;

Revoking permissions:
---------------------

  Revoke update on ora8pm.my_view from my_role;

** Dropping Roles

ex:- Drop Role My_role;     -- DBA can drop


PL/SQL:
-------

  -> PL stands for Programming / Procedural Language

  -> It is Extension to SQL

  -> PL-SQL supports all sql statements and it supports Programming features

  -> PL/SQL is embedded with SQL

  -> PL/SQL is introduced in 1990's

Main features of PL/SQL :
-------------------------

-> pl/sql executes a block of statements as a unit

-> pl/sql supports control structures & iteration control statements

-> pl/sql supports to handle errors by using exception handling

-> pl/sql supports composite datatypes(user defined datatypes)

-> pl/sql supports automatic execution of code through db triggers

-> pl/sql supports sub-programs(procedures, user-defined functions)

-> pl/sql supports Packages

-> pl/sql supports OOPs features

-> pl/sql supports client side appl. or server side appl. or both client & server side
   appl.

what is a block ?

 -> Block is a collection of sql & pl/sql statements

 -> pl/sql supports two types of blocks

          i. anonymous block

         ii. named block

i. Anonymous block :
--------------------

  -> this block of programs are not stored in db permanently

  -> All Anonymous block programs are also called as NAMELESS blocks

  -> Anonymous block programs are start with 'DECLARE' or 'BEGIN' statement

  -> To save this block of statements user can explictely save by using 'SAVE' command

Anonymous Block Structure :
---------------------------

[declare
 <variable-declaration>;]
Begin
  <exec-statements>;
[Exception
  <exec-statements>;]
End;
/

Simple Block :
--------------
begin
 <exec-statements>;
End;
/

'/'  -> to execute anoymous block programs

ii. Named Blocks :
------------------

  -> this block of programs are stored in db permanently

  -> All Named Block Programs are start with 'CREATE' statement

       ex: procedures , Functions, packages & triggers

** pl/sql supports DDL , DML, DRL  Commands

** pl/sql not supported DCL & TCL  Commands

 
PL/SQL DATATYPES:
-----------------

 -> pL/sql supports all SQL datatypes & some extra datatypes

I. SCALAR DATATYPES:
--------------------

   i. number  ii. char   iii. varchar2   iv. date

II. Composite Datatypes:
------------------------

   ex:  pl/sql record,  pl/sql table

III. Referenced Datatypes :
---------------------------

    i. %type,      ii. %rowtype

IV.  Boolean datatype :
-----------------------

    -> it accepts true or false

V. Un-structured datatypes:
---------------------------

    ex: LOB, BLOB, CLOB, etc.,

comments:
---------

  -> pl/sql supports two types comments

i. single line comment

ii. multi-line comment


  -> comment is a description of the given statement

i. single line comment:
-----------------------

  -> comment contains single line is called as single line  comment.

  -> single line comments are represented with --

 ex:-  -- pl/sql block for to display welcome message

ii. multi-line comment
-----------------------
 
  -> comment contains morethan line is called as multi line  comment.

  -> multi line comments are represented with /*   */


ex:-  /* pl/sql block for to 
                      display welcome message  */


:=  
---

  -> it is an assignment operator

    ex:  a := 10

note:  10 value is assigned into 'a' variable

DBMS_OUTPUT.PUT_LINE(arg1) :
============================

  -> It is one of the pl/sql output statement

  -> It sends output to SQL BUFFER

  -> this statements accepts only one argument at a time

syn:-

  dbms_output.put_line( 'welcome' );

dbms_output: it is one of the pre-defined package name

put_line: it is one of the pre-defined procedure

SET SERVEROUTPUT ON :
---------------------

  -> it sends output from SQL BUFFER to output screen

  -> It is a session valid

Ex:-
----

  -- write a pl/sql block to display welcome message

begin
 dbms_output.put_line('Welcome to pl/sql');
end;
/

Welcome to pl/sql

PL/SQL procedure successfully completed.


-- write a pl/sql block to find sum of two numbers

declare
 x number(4) := 10;
 y number(4) := 20;
 z number(8);
Begin
 z := x + y;
 dbms_output.put_line( z );
End;
/

30

PL/SQL procedure successfully completed.
 

declare
 x number(4) := 10;
 y number(4) := 20;
 z number(8);
Begin
 z := x + y;
 dbms_output.put_line( 'sum of two numbers = '||z );
End;
/

sum of two numbers = 30

PL/SQL procedure successfully completed.

To take values at runtime :
---------------------------
declare
 x number(4) := &x;
 y number(4) := &y;
 z number(8);
Begin
 z := x + y;
 dbms_output.put_line( 'sum of two numbers = '||z );
End;
/

Enter value for x: 90
old   2:  x number(4) := &x;
new   2:  x number(4) := 90;
Enter value for y: 70
old   3:  y number(4) := &y;
new   3:  y number(4) := 70;
sum of two numbers = 160

PL/SQL procedure successfully completed.

SQL> /
Enter value for x: 78
old   2:  x number(4) := &x;
new   2:  x number(4) := 78;
Enter value for y: 45
old   3:  y number(4) := &y;
new   3:  y number(4) := 45;
sum of two numbers = 123

PL/SQL procedure successfully completed.

SQL>/

Enter value for x: 80
Enter value for y: 90
sum of two numbers = 170

PL/SQL procedure successfully completed.

-- write a pl/sql block to swap two numbers without using third variable

declare
 x number(4) := 10;
 y number(4) := 20;
Begin
 dbms_output.put_line('Before swaping x = '|| x ||' y = '||y );
 x := x + y;
 y := x - y;
 x := x - y;
 dbms_output.put_line('After swaping x = '|| x ||' y = '||y );
End;
/

o/p:

Before swaping x = 10 y = 20
After swaping  x = 20 y = 10

PL/SQL procedure successfully completed.

PL/SQL Blocks are interact with DATABASE TABLES :
-------------------------------------------------

SELECT..INTO Clause :
---------------------

  -> It is used to copies db column values into pl/sql variables

  -> no.of db columns should be matched with no.of pl/sql variables and 
     corresponding columns datatypes should be same.

syn:- 

   Select col1, col2,... Into var1, var2,... from <table_name> where <condition>;


ex:-

   -- write a pl/sql block to display 7788 employ no. employee job

declare
 v_job varchar(10);
Begin
 select job into v_job from emp where empno=7788;
 dbms_output.put_line( v_job );
End;
/

ANALYST

PL/SQL procedure successfully completed.

-- write a pl/sql block to input employee no and display corresponding employee net salary  

                 netsal = sal + comm

declare
 v_sal number(8,2);
 v_comm number(7,2);
 netsal number(8,2);
Begin
 select sal, comm into v_sal, v_comm from emp where empno=&empno;
 netsal := v_sal + nvl( v_comm,0);
 dbms_output.put_line( 'Salary    Rs.'||v_sal);
 dbms_output.put_line( 'Comm      Rs.'||nvl(v_comm,0));
 dbms_output.put_line( 'Netsasl   Rs.'||netsal);
end;
/


Enter value for empno: 7788
Salary    Rs.3000
Comm      Rs.0
Netsasl   Rs.3000

PL/SQL procedure successfully completed.

SQL> /
Enter value for empno: 7521
Salary    Rs.1250
Comm      Rs.500
Netsasl   Rs.1750

PL/SQL procedure successfully completed.

-- write a pl/sql block to input employee no. and display corresponding employee name, salary & deptno.

declare
 v_empno number(4) := &empno;
 v_ename varchar(10);
 v_sal number(7,2);
 v_deptno number(2);
Begin
 select ename, sal, deptno into v_ename, v_sal, v_deptno from emp
                                                  where empno = v_empno;
 dbms_output.put_line( v_empno || ' ' || v_ename ||' '||v_sal ||' '||v_deptno );
End;
/

REFERENCED DATATYPES :
---------------------

  -> these datatypes are used to declare variable datatype dynamically

  -> PL/SQL supports two types of REFERENCED datatypes

           i. column type ( %type )

          ii. Table type or Record type ( %rowtype )

i. column type ( %type ) :
--------------------------

  -> this datatype is used to declare variable datatype dynamically according corresponding
     table of column structure

syn:-  

  <variable_name> <table_name>.<column_name>%type;

ex:-

  v_empno emp.empno%type;

Example program :
-----------------
  
declare
 v_empno emp.empno%type := &empno;
 v_ename emp.ename%type;
 v_sal emp.sal%type;
 v_deptno emp.deptno%type;
Begin
 select ename, sal, deptno into v_ename, v_sal, v_deptno from emp
                                                  where empno = v_empno;
 dbms_output.put_line( v_empno || ' ' || v_ename ||' '||v_sal ||' '||v_deptno );
End;
/

Enter value for empno: 7788
7788 SCOTT 3000 20

PL/SQL procedure successfully completed.


ii. TABLE TYPE( %rowtype ):
---------------------------

   -> this datatype is used to declare variable datatype dynamically according corresponding entire table or
      row structure.

syn:-  

   <variable_name> <table_name>%rowtype;

ex:-

   e_rec emp%rowtype;

note: e_rec is a record type variable and it holds one record at a time

Example program:
----------------

  -- write a pl/sql block to input employee id and display corresponding employee record

declare
 e emp%rowtype;
Begin
 select * into e from emp where empno=&empno;
 dbms_output.put_line( e.empno ||' '||e.ename||' '||e.job||' '||e.mgr||' '||e.hiredate||' '||
                       e.sal||' '||e.deptno);
End;
/

Enter value for empno: 7788
7788 SCOTT ANALYST 7566 09-DEC-82 3000 20

PL/SQL procedure successfully completed.

SQL> /
Enter value for empno: 7521
7521 WARD SALESMAN 7698 22-FEB-81 1250 30

PL/SQL procedure successfully completed.


Rowtype attributes using INSERT & UPDATE commands :
---------------------------------------------------

 -- write a pl/sql block to insert data into dept. table

   declare
     d dept%rowtype;
   Begin
     d.deptno := 50;
     d.dname := 'maths';
     d.loc := 'hyd';
     Insert into dept values d;
     dbms_output.put_line( 'record inserted' );
    End;

record inserted

PL/SQL procedure successfully completed.

SQL> select * from dept;

DEPTNO DNAME          LOC
------ -------------- -------------
    10 ACCOUNTING     NEW YORK
    20 RESEARCH       DALLAS
    30 SALES          CHICAGO
    40 OPERATIONS     BOSTON
    50 maths          hyd

UPDATE command :
----------------

  -- write a pl/sql block to update dept record

declare
     d dept%rowtype;
   Begin
     d.deptno := 50;
     d.dname := 'English';
     d.loc := 'sec';
     Update dept set row=d where deptno=d.deptno;
     dbms_output.put_line( 'record updated' );
    End;
  /

record updated

PL/SQL procedure successfully completed.

SQL> select * from dept;

DEPTNO DNAME          LOC
------ -------------- -------------
    10 ACCOUNTING     NEW YORK
    20 RESEARCH       DALLAS
    30 SALES          CHICAGO
    40 OPERATIONS     BOSTON
    50 English        sec

CONTROL STRUCTURES :
--------------------

  -> Control structructure are used to control flow of the programs

  -> Pl/sql supports 4 types control structures

          I. Conditional Control Structures

         II. Branching Control Structures

        III. Iteration control Structures

         IV. Un-conditional Control Structures

I. Conditional Control Structures :
-----------------------------------

  -> conditional control structures again classified into 4 types

           i. simple if

          ii. if..else

         iii. nested if

          iv. elsif lader


i. simple if :
--------------

  -> it contains only TRUE block

syn:-

if <condition> then
    <exec-statements>;    -- true block
End if;


Ex:-

declare
 flag boolean := &flag;
begin
 if flag=true then
     dbms_output.put_line('we r in true block');
 end if;
 dbms_output.put_line('end of the program');
End;
/

Enter value for flag: true
we r in true block
end of the program

PL/SQL procedure successfully completed.

SQL> /
Enter value for flag: false
end of the program

PL/SQL procedure successfully completed.


ii. if..else :
--------------

  -> it contains both true and false blocks

syn:-

if <condition> then
    <exec-statements>;     -- true block
else
    <exec-statements>;      -- false block
end if;

ex:-

 -- write a pl/sql block to find given no. is even or odd

declare
 num number(4) := &Num;
Begin
 if mod(num,2) = 0 then
     dbms_output.put_line('given no. is even');
 else
     dbms_output.put_line('given no. is odd');
 end if;
End;
/

Enter value for num: 10
given no. is even

PL/SQL procedure successfully completed.

SQL> /
Enter value for num: 13
given no. is odd

PL/SQL procedure successfully completed.

iii. nested if :
----------------

  -> if within the if is called as nested if

syn:-

if <condition> then
     if <condition> then
            <exec-statements>;
     else
            <exec-statements>;
     end if;
else
    if <condition> then
        <exec-statements>;
    end if;
End if;
/

ex:-

  -- write a pl/sql block to declare employee bonus based on following conditions.

          if employee type is 'permanent' and experience >=10 then 40% increment

          if employee type is 'permanent' and experience <10 then  20% increment
         
          if employee type is 'temporary' then 10% increment

Declare
 emp_type char(1) := &emp_type;
 expr number(5,2) := &expr;
Begin
 if emp_type='p' then
       if expr >=10 then
          dbms_output.put_line('employee will get 40% bonus');
       else
          dbms_output.put_line('employee will get 20% bonus');
       end if;
else
  if emp_type='t' then
          dbms_output.put_line('employee will get 10% bonus');
  end if;
End if;
End;
/
      
Enter value for emp_type: 'p'
Enter value for expr: 15
employee will get 40% bonus

PL/SQL procedure successfully completed.

SQL> /
Enter value for emp_type: 'p'
Enter value for expr: 6
employee will get 20% bonus

PL/SQL procedure successfully completed.

SQL> /
Enter value for emp_type: 't'
Enter value for expr: 15
employee will get 10% bonus

PL/SQL procedure successfully completed.

iv. Elsif Lader :
-----------------

  -> by using this control structure we can check multiple conditions continuously.

syn:-

if <condition> then
    <exec-statements>;
elsif <condition> then
    <exec-statements>;
elsif <condition> then
    <exec-statements>;
.
.
else 
  <exec-statements>;
End if;

-- write a pl/sql block to find student grade

declare
 v_avg number(5,2) := &avg;
Begin
 if v_avg >=70 then
     dbms_output.put_line('Distinction');
 elsif v_avg >=60 then
     dbms_output.put_line('First Class');
 elsif v_avg >=50 then
     dbms_output.put_line('Second Class');
 else
     dbms_output.put_line('Third Class');
 end if;
End;
/

Enter value for avg: 78
Distinction

PL/SQL procedure successfully completed.

SQL> /
Enter value for avg: 64
First Class

PL/SQL procedure successfully completed.

SQL> /
Enter value for avg: 43
Third Class

PL/SQL procedure successfully completed.

II. Branching Control Structures :
----------------------------------

  -> this control structure is used to check the conditions

  -> Branching control is also called as JUMP control structure

          i. case

syn:-

Case <variable/expression>
When <constant> then
  <exec-statements>;
when <constant> then
  <exec-statements>;
.
.
else
  <exec-statments>;
end case;

ex:-

Declare
 color char(1) := '&color';
begin
 case color
 when 'r' then 
   dbms_output.put_line('u r selected red color');
 when 'b' then 
   dbms_output.put_line('u r selected blue color');
 when 'y' then 
   dbms_output.put_line('u r selected yellow color');
 else
   dbms_output.put_line('your selection is wrong, plz. try again!!!');
 end case;
End;
/

Enter value for color: r
u r selected red color

PL/SQL procedure successfully completed.

SQL> /
Enter value for color: y
u r selected yellow color

PL/SQL procedure successfully completed.

SQL> /
Enter value for color: x
your selection is wrong, plz. try again!!!

PL/SQL procedure successfully completed.

III. Iteration control structures :
-----------------------------------

  -> The statement are executed 'n' no.of times until condition becomes false

  -> there are 4 types of iteration control statements

        i. simple loop

       ii. while loop

      iii. for loop

       iv. for cursor

i. Simple Loop :
----------------

  -> It is an Infinite Loop

syn:-

Loop
  <exec-statements>;
End Loop;

ex:-

Begin
Loop
  dbms_output.put_line('welcome');
End Loop;
End;
/

How to break simple loop :
--------------------------

 -> break the simple loop there are two methods

i. if <condition> then
        Exit;
   end if;

ex:-

Declare
 i number(4) := 1;
Begin
 Loop
  if i > 10 then
     Exit;
  end if;
  dbms_output.put_line( 'welcome' );
  i := i + 1;
 End Loop;
End;
/
welcome
welcome
welcome
welcome
welcome
welcome
welcome
welcome
welcome
welcome

PL/SQL procedure successfully completed.

ii. EXIT WHEN <Condition>;

  -> EXIT is executed when condition is true

Ex:-

Declare
 i number(4) := 1;
Begin
 Loop
  Exit when i>10;
  dbms_output.put_line( 'welcome' );
  i := i + 1;
 End Loop;
End;
/

ii. While Loop :
----------------

  -> In while loop first it checks the condition

  -> In while loop, Loop is executed until condition becomes false

Syn:-

While( <condition> )
Loop
  <exec-statements>;
  incr/decr;
End Loop;
/

Example:-
---------

  -- write a pl/sql block to display 1 to 10 numbers

Declare
 i number(4) := 1;
Begin
 While( i <=10 )
 Loop
   dbms_output.put_line( i ) ;
   i := i + 1;
 End Loop;
End;
/

1
2
3
4
5
6
7
8
9
10

PL/SQL procedure successfully completed.

-- write a pl/sql block to display 1 to 10 in reverse order

Declare
 i number(4) := 10;
Begin
 while( i >= 1)
 Loop
   dbms_output.put_line( i );
   i := i - 1;
 End Loop;
end;
/
10
9
8
7
6
5
4
3
2
1

PL/SQL procedure successfully completed.

-- write a pl/sql block to display Multiplication table 

5*1=5
5*2=10
.
.
5*10=50

Declare
 N number(4) :=&n;    -- 5
 I number(4) :=1;
Begin
 While( i <=10 )
 Loop
  dbms_output.put_line( N || '*' || i || '=' || (N*i) );
  i := i + 1;
 End Loop;
End;
/

Enter value for n: 5
5*1=5
5*2=10
5*3=15
5*4=20
5*5=25
5*6=30
5*7=35
5*8=40
5*9=45
5*10=50

PL/SQL procedure successfully completed.

-- write a pl/sql find Factorial of a given no.

5! = 120

Declare
 N Number(4) := &N;  -- 5
 Fact Number(10) := 1;
Begin
 While( N != 0 )
 Loop
   Fact := Fact * N;
   N := N - 1;
 End Loop;
 dbms_output.put_line( 'Factorial of a Given No. is ' || Fact );
End;
/

Enter value for n: 5
Factorial of a Given No. is 120

PL/SQL procedure successfully completed.

-- write a pl/sql block find reverse number

-- write a pl/sql block input a string and displays with Vertical Order

input: naresh
output:
n
a
r
e
s
h

declare
 str varchar(20) := &str;
 i number(4) :=1;
Begin
 while( i <= length(str) )
 Loop
     dbms_output.put_line( substr( str, i,1 ) );
     i := i + 1;  
 End Loop;
End;
/

Enter value for str: 'naresh'
n
a
r
e
s
h

PL/SQL procedure successfully completed.

SQL> /
Enter value for str: 'krishna'
k
r
i
s
h
n
a

PL/SQL procedure successfully completed.


iii. FOR LOOP :
---------------

  ->  In for loop by default Index value is incremented by 1

syn:-

For <index_variable> IN <start_value>..<end_value>
Loop
 <exec-statements>;
End Loop;
/

-> Index variable no need to declare in Declaration part

-> <start_value> should be < <end_value>

-> .. represents range

Ex:-

  -- write a pl/sql block to display 1 to 10 numbers

Begin
 For i in 1..10
 Loop
   dbms_output.put_line( i );
 End Loop;
End;
/

1
2
3
4
5
6
7
8
9
10

PL/SQL procedure successfully completed.

-- write pl/sql block to 1 to 10 in reverse order

begin
 for i in reverse 1..10
 loop
   dbms_output.put_line( i );
 end Loop;
End;
/

10
9
8
7
6
5
4
3
2
1

PL/SQL procedure successfully completed.

iv. FOR CURSOR :
----------------

Declare
 v_Ename varchar(10);
begin
 select ename into v_ename from emp 
				where deptno=10;
 dbms_output.put_line( v_ename );
End;
/

Declare
*
ERROR at line 1:
ORA-01422: exact fetch returns more than requested number of rows
ORA-06512: at line 4


note: select..into clause should be returns single record/value at a time

CURSORS :
---------

  -> Cursor is one of the private context area 

  -> It creates a temporary buffer and it holds transactional data

  -> Cursors created based on SELECT statement output

  -> Cursor Programs are not stored in db permanently

  -> In Pl/sql block whenever select..into clause returns morethan one record then to use CURSORS

** pl/sql supports two types of CURSORS :
-----------------------------------------

I. STATIC CURSOR

II. DYNAMIC CURSOR or REF CURSOR

I. STATIC CURSORS:
------------------

  -> While declaring the cursor to provide SELECT statement is called as STATIC CURSOR

  -> Static cursors are classified into two types

          i. Explicit Cursors

         ii. Implicit Cursors

i. Explicit Cursors :
---------------------

  -> These cursors are defined by user Explicitely

  -> To write explicit cursor programs user must know cursors operations and attributes

Cursor Operations :
-------------------

a. Declaring cursor :
---------------------

  -> In declaration part we can declare the cursor

syn:-

 Cursor <cursor_name> IS <Select statment>;

ex:- 

 Cursor my_cur is select ename from emp;

b. Open <cursor_name> :
-----------------------

  -> It opens the cursor

  -> Memory is allocated after opened

ex: open my_cur;

c. Fetch <cursor_name> Into <pl/sql variables> :
------------------------------------------------

  -> it fetches data from cursor into pl/sql variables

  -> fetch statement fetches one record at a time

ex:-  fetch my_cur into v_ename

d. close <cursor_name> :
------------------------

  -> It closes the cursor

  -> Allocated memory will be de-allocated

ex:- close my_cur;

Cursor Attributes :
-------------------

  -> It returns status of the cursor

 syn:-  <cursor_name>%<attribute>;


a. %isopen :
------------

  -> it returns True, when cursor opened successfully

b. %found :
-----------

  -> It returns true, when cursor contains data

c. %notfound:
-------------

  -> It returns True, when cursor doesn't find any data

d. %rowcount :
--------------

   -> It returns number

   -> No.of of fetch statements are executed

Ex:-

  -- cursor program for to demonistrate cursors operations and attributes

Declare
 cursor my_cur is select ename from emp where deptno=60;
 v_ename emp.ename%type;
Begin
 open my_cur;
 if my_cur%isopen then
    dbms_output.put_line('cursor opened successfully.');
 end if;
 fetch my_cur into v_ename;
 if my_cur%found then
    dbms_output.put_line('cursor contains data');
 elsif my_cur%notfound then
    dbms_output.put_line('cursor doesn''t find any data');    
 end if;
 close my_cur;
End;
/

cursor opened successfully.
cursor contains data

PL/SQL procedure successfully completed.

 
 
-- write cursor program to display all employee names

declare
 cursor my_cur is select ename from emp;
 v_ename emp.ename%type;
Begin
 open my_cur;
 if my_cur%isopen then
    dbms_output.put_line('cursor opened successfully.');
 end if;
 fetch my_cur into v_ename;
 dbms_output.put_line( v_ename );
 fetch my_cur into v_ename;
 dbms_output.put_line( v_ename );
 fetch my_cur into v_ename;
 dbms_output.put_line( v_ename );
 close my_cur;
End;
/

cursor opened successfully.
SMITH
ALLEN
WARD

PL/SQL procedure successfully completed.


note: above program returns first three employee names only, to display all employee names then to use LOOPs

declare
 cursor my_cur is select ename from emp;
 v_ename emp.ename%type;
Begin
 open my_cur;
 if my_cur%isopen then
    dbms_output.put_line('cursor opened successfully.');
 end if;
 Loop
   fetch my_cur into v_ename;
   Exit when my_cur%notfound;
   dbms_output.put_line( v_ename );
 End Loop;
 close my_cur;
End;
/
  
cursor opened successfully.
SMITH
ALLEN
WARD
JONES
MARTIN
BLAKE
CLARK
SCOTT
KING
TURNER
ADAMS
JAMES
FORD
MILLER

PL/SQL procedure successfully completed.

-- write a cursor program to display employee no, ename, sal & deptnos


-- write a cursor program to find top-5 maximum salaries

Declare
 Cursor C1 is select distinct(Sal) from Emp Order by Sal Desc;
 v_sal emp.sal%type;
Begin
 Open c1;
 Loop
   Fetch c1 into v_sal;
   Exit when c1%rowcount>5;
   dbms_output.put_line( v_sal );
 End Loop;
 close c1;
End;
/

5000
3000
2975
2850
2450

PL/SQL procedure successfully completed.

Cursors using WHILE LOOP :
--------------------------

 -- write a cursor program to display all employee details

Declare
 cursor c1 is select * from emp;
 e c1%rowtype;        -- cursor attribute ( %rowtype )
Begin
 Open c1;
 Fetch c1 into e;
 While ( c1%found  )
 Loop
    dbms_output.put_line( e.empno||' '||e.ename||' '||e.job||' '||e.mgr||' '||e.hiredate||' '||e.sal||
                          ' '||e.comm||' '||e.deptno);
    Fetch c1 into e;
 End Loop;
 close c1;
End;
/

 -- write a cursor program to display alternate records ( even records )

Declare
 cursor c1 is select * from emp;
 e c1%rowtype;        -- cursor attribute ( %rowtype )
Begin
 Open c1;
 Fetch c1 into e;
 While ( c1%found  )
 Loop
  if mod( c1%rowcount,2)=0 then
    dbms_output.put_line( c1%rowcount||' '||e.empno||' '||e.ename||' '||e.job||' '||e.mgr||' '||e.hiredate||
			' '||e.sal||' '||e.comm||' '||e.deptno);
  end if;
    Fetch c1 into e;
 End Loop;
 close c1;
End;
/

2 7499 ALLEN SALESMAN 7698 20-FEB-81 1600 300 30
4 7566 JONES MANAGER 7839 02-APR-81 2975  20
6 7698 BLAKE MANAGER 7839 01-MAY-81 2850  30
8 7788 SCOTT ANALYST 7566 09-DEC-82 3000  20
10 7844 TURNER SALESMAN 7698 08-SEP-81 1500 0 30
12 7900 JAMES CLERK 7698 03-DEC-81 950  30
14 7934 MILLER CLERK 7782 23-JAN-82 1300  10

PL/SQL procedure successfully completed.

-- Write a cursor program to increment employee salaries based on following conditions and incremented details    should be stored in INCR table

          if Employee job is MANAGER/ANALYST then 10%

          if Employee job SALESMAN/CLERK then 30%

          for other jobs 5% increment

Table creation:
---------------

Create table Emp_incr
( Empno Number(4),
  Incr_date Date,
  Incr_Amt Number(8,2)
);

Program :
---------

Declare
 cursor e_cur is select Empno, Job, Sal from emp;
 e e_cur%rowtype;
 v_incr_sal Number(8,2);
Begin
 Open e_cur;
 Loop
  Fetch e_cur into e;
  Exit when e_cur%notfound;
  if e.job in ('MANAGER','ANALYST') then
       v_incr_sal := e.sal * 0.1;
  elsif e.job in ('CLERK','SALESMAN') then
       v_incr_sal := e.sal * 0.3;
  else
       v_incr_sal := e.sal * 0.05;
  end if;
  update emp set sal= sal + v_incr_sal where empno=e.empno;
  Insert into Emp_incr values ( e.empno, sysdate, v_incr_sal);
 End Loop;
End;
/

SQL> select * from emp_incr;

 EMPNO INCR_DATE INCR_AMT
------ --------- --------
  7369 22-FEB-22      240
  7499 22-FEB-22      480
  7521 22-FEB-22      375
  7566 22-FEB-22    297.5
  7654 22-FEB-22      375
  7698 22-FEB-22      285
  7782 22-FEB-22      245

ii. IMPLICIT CURSORS :
----------------------

  -> These cursors are defined by ORACLE automatically
  
  -> In Implicit cursors Oracle Automatically....

            i. open the cursor

           ii. fetching data into index variable

          iii. after fetching all records it closes the cursor

  -> Implicit Cursors supports cursor attributes

i. SQL%FOUND :
--------------

  -> It returns true, WHEN on SQL prompt atleast one record SELECTED / MANIPULATED

ii. SQL%NOTFOUND:
-----------------

  -> It returns True, when on SQL prompt No Records SELECTED / MANIPULATED

iii. SQL%ROWCOUNT:
------------------

  -> It returns Number, No.of Records are Selected / Manipulated


Example:
--------

  Delete from Emp Where Deptno=10;

Example:
--------

Begin
 Update Emp set Sal = Sal + 100 where empno =7788;
 if sql%found then
    dbms_output.put_line('Salary Incremented Successfully.');
 elsif sql%notfound then
    dbms_output.put_line('Employ Record Not Found');
 end if;
End;
/

Salary Incremented Successfully.

PL/SQL procedure successfully completed.

Note: All SQL commands are example for IMPLICIT CURSORS

drawback of static cursor :
---------------------------

declare
  cursor c1 is select ename from emp;
  v_ename emp.ename%type;
begin
  open c1;
  loop
   fetch c1 into v_ename;
   exit when c1%notfound;
   dbms_output.put_line( v_ename );
  end loop;
  close c1;
  dbms_output.put_line('-------------');
  open c1;
  loop
   fetch c1 into v_ename;
   exit when c1%notfound;
   dbms_output.put_line( v_ename );
  end loop;
  close c1;
end;
/

SMITH
ALLEN
WARD
JONES
MARTIN
BLAKE
CLARK
SCOTT
KING
TURNER
ADAMS
JAMES
FORD
MILLER
-------------
SMITH
ALLEN
WARD
JONES
MARTIN
BLAKE
CLARK
SCOTT
KING
TURNER
ADAMS
JAMES
FORD
MILLER

note: in above program howmany times to  open the cursor it returns same output that is static

II. DYNAMIC CURSORS or REF CURSORS :
------------------------------------

  -> To declare the cursor without any SELECT statement

  -> SELECT statement will be provided while opening the cursor

  -> Dynamic cursors are classified into two types

          i. EXPLICIT Dynamic Cursor

         ii. IMPLICIT Dynamic Cursor

i. Explicit Dynamic Cursor :
----------------------------

  -> Dynamic cursor name is defined by user explicitely is called as Explicit Dynamic Cursor

syn:- type <cursor_name> is ref cursor;

ex:-

-- write a cursor program to display employee details

Declare 
  type emp_ref_cur is ref cursor;
  v_cur emp_ref_cur;
  e_cur emp_ref_cur;
  v_empno emp.empno%type;
  v_job emp.job%type;
  v_dname dept.dname%type;
  v_grade salgrade.grade%type;
Begin
  open v_cur for select empno, job from emp;
  loop
   fetch v_cur into v_empno, v_job;
   exit when v_cur%notfound;
   dbms_output.put_line( v_empno ||' '||v_job );
  end loop;
  close v_cur;
  dbms_output.put_line('---------------');
  open v_cur for select empno, dname, grade from emp, dept, salgrade
						where emp.deptno=dept.deptno
								and
						     sal between losal and hisal;
  loop
    fetch v_cur into v_empno, v_dname, v_grade;
    exit when v_cur%notfound;
    dbms_output.put_line( v_empno || ' employee working in '||v_dname||' and his grade is ' || v_grade);
  End Loop;
  close v_cur;
End;
/

7369 CLERK
7499 SALESMAN
7521 SALESMAN
7566 MANAGER
7654 SALESMAN
7698 MANAGER
7782 MANAGER
7788 ANALYST
7839 PRESIDENT
7844 SALESMAN
7876 CLERK
7900 CLERK
7902 ANALYST
7934 CLERK
---------------
7369 employee working in RESEARCH and his grade is 1
7499 employee working in SALES and his grade is 3
7521 employee working in SALES and his grade is 2
7566 employee working in RESEARCH and his grade is 4
7654 employee working in SALES and his grade is 2
7698 employee working in SALES and his grade is 4
7782 employee working in ACCOUNTING and his grade is 4
7788 employee working in RESEARCH and his grade is 4
7839 employee working in ACCOUNTING and his grade is 5
7844 employee working in SALES and his grade is 3
7876 employee working in RESEARCH and his grade is 1
7900 employee working in SALES and his grade is 1
7902 employee working in RESEARCH and his grade is 4
7934 employee working in ACCOUNTING and his grade is 2

PL/SQL procedure successfully completed.

ii. IMPLICIT DYNAMIC CURSOR :
-----------------------------

  -> Oracle provided Implicit Dynamic Cursor Name is 

             i. SYS_REFCURSOR;

ex:-

Declare 
  v_cur sys_refcursor;
  v_empno emp.empno%type;
  v_job emp.job%type;
  v_dname dept.dname%type;
  v_grade salgrade.grade%type;
Begin
  open v_cur for select empno, job from emp;
  loop
   fetch v_cur into v_empno, v_job;
   exit when v_cur%notfound;
   dbms_output.put_line( v_empno ||' '||v_job );
  end loop;
  close v_cur;
  dbms_output.put_line('---------------');
  open v_cur for select empno, dname, grade from emp, dept, salgrade
						where emp.deptno=dept.deptno
								and
						     sal between losal and hisal;
  loop
    fetch v_cur into v_empno, v_dname, v_grade;
    exit when v_cur%notfound;
    dbms_output.put_line( v_empno || ' employee working in '||v_dname||' and his grade is ' || v_grade);
  End Loop;
  close v_cur;
End;
/

7369 CLERK
7499 SALESMAN
7521 SALESMAN
7566 MANAGER
7654 SALESMAN
7698 MANAGER
7782 MANAGER
7788 ANALYST
7839 PRESIDENT
7844 SALESMAN
7876 CLERK
7900 CLERK
7902 ANALYST
7934 CLERK
---------------
7369 employee working in RESEARCH and his grade is 1
7499 employee working in SALES and his grade is 3
7521 employee working in SALES and his grade is 2
7566 employee working in RESEARCH and his grade is 4
7654 employee working in SALES and his grade is 2
7698 employee working in SALES and his grade is 4
7782 employee working in ACCOUNTING and his grade is 4
7788 employee working in RESEARCH and his grade is 4
7839 employee working in ACCOUNTING and his grade is 5
7844 employee working in SALES and his grade is 3
7876 employee working in RESEARCH and his grade is 1
7900 employee working in SALES and his grade is 1
7902 employee working in RESEARCH and his grade is 4
7934 employee working in ACCOUNTING and his grade is 2

PL/SQL procedure successfully completed.
  
FOR CURSOR :
------------

  -> Cursor using FOR loop is called as FOR CURSOR

  -> In For Cursors For Loop Automatically....

             i. Open the cursor

            ii. Fetch each record into Index Variable

           iii. After Fetching all records it closes the cursor

ex:-

  -- write a cursor program to display dept. details

Declare
 cursor d_cur is select * from Dept;
Begin
  For d in d_cur
  Loop
    dbms_output.put_line( d.deptno ||' '||d.dname ||' '||d.loc );
  End Loop;
End;
/


EXCEPTION HANDLING :
--------------------

  -> PL/SQL errors are termed as Exceptions
  
  -> Basically errors are three types

         i. syntax errors

        ii. logical errors

       iii. runtime errors( exceptions)

  -> By using Exception handling we can handle Runtime Errors

  -> In PL/SQL errors are classified into three types

         I. PRE-DEFINED Exceptions

        II. USER-DEFINED Exceptions

       III. NON PRE-DEFINED Exceptions

I. PRE-DEFINED Exceptions:
--------------------------

  -> While executing the program oracle returns some runtime errors are called as pre-defined exceptions

  -> In this Exceptions...

          -> Exception Name is defined by Oracle

          -> Activated by Oracle

          -> Solution is provided by User

ex:-

NO_DATA_FOUND:  it is one of the pre-defined exception name and used to handle SELECT..INTO clause is not                 returning any record
Declare
 v_ename emp.ename%type;
Begin
 select ename into v_ename from emp where empno = 9000;
 dbms_output.put_line( v_ename );
Exception
 when no_data_found then
   dbms_output.put_line('Employ Record Not Found.');
End;
/

Employ Record Not Found.

PL/SQL procedure successfully completed.


TOO_MANY_ROWS :
---------------

  -> this exception name is used to in PL/SQL block whenever SELECT..INTO
     clause returns morethan one record

ex:-

Declare
 v_ename emp.ename%type;
Begin
 select ename into v_ename from emp;
 dbms_output.put_line( v_ename );
Exception
 when too_many_rows then
   dbms_output.put_line( 'Morethan One Record Found.');
End;
/

Morethan One Record Found.

PL/SQL procedure successfully completed.

ZERO_DIVIDE :
-------------

  -> it is used to handle any value is divide with 0

Ex:-

declare
 x number(4) := &x;
 y number(4) := &y;
Begin
 dbms_output.put_line( 'division of two numbers = '||(x/y));
Exception
 when zero_divide then
   dbms_output.put_line('Divisor Should not be Equals to 0');
End;
/

Enter value for x: 10
Enter value for y: 0
Divisor Should not be Equals to 0

PL/SQL procedure successfully completed.

INVALID_NUMBER :
----------------

  -> It is used to handel try to convert STRING to NUMBER datatype

Begin
 Insert into dept values ( 'Maths', 50, 'hyd' );
Exception
 when Invalid_Number then
   dbms_output.put_line('Insert Appropriate Data Into Table');
end;
/

Insert Appropriate Data Into Table

PL/SQL procedure successfully completed.

CURSOR_ALREADY_OPEN :
---------------------

  -> used to handle, to re-open the cursor without close

declare
 cursor c1 is select ename from emp;
begin
 open c1;
 open c1;
 close c1;
Exception
 when cursor_already_open then
     dbms_output.put_line('First close the cursor before to re-open');
end;
/

First close the cursor before to re-open

PL/SQL procedure successfully completed.

II. USER DEFINED EXCEPTIONS:
----------------------------

  -> According to End-user requirement developer raise error messages are called
     User-defined Exceptions

  -> In User-defined exceptions...

           i. Exception Name is defined by User

          ii. Activate by user(  by using RAISE statement )

         iii. Solution is provided by User

-> PL/SQL supports two pre-defined procedures

    i. RAISE 

   ii. RAISE_APPLICATION_ERROR

i. RAISE :
----------

  -> this procedure used to throws User Defined Exception Name to Exception Block

syn:- RAISE <user-defined_exception_name>;

ii. RAISE_APPLICATION_ERROR :-
------------------------------

 -> this procedure used to displays User defined error message with Error Code

 -> it supports two parameters

syn:- RAISE_APPLICATION_ERROR( user_defined_eror_code, user_defined_error_message);

 ** User defined Error codes range from -20001 to -20999

ex:-

  -- write user defined exception handling program to restrict UPDATE command every thursday

Declare
 Holiday Exception;
Begin
 if to_char(sysdate, 'dy') = 'thu' then
     raise holiday;
 else
     update emp set sal = sal + 100 where empno = 7788;
 end if;
Exception
 when holiday then
   raise_application_error(-20001, 'Today Holiday, Trans. are not allowed.');
End;
/

Declare
*
ERROR at line 1:
ORA-20001: Today Holiday, Trans. are not allowed.
ORA-06512: at line 11


-- Write a user defined exception program to handel any value divide with 0

declare
 x number(3) := &x;
 y number(3) := &y;
 ABC Exception;
Begin
 if y=0 then
    raise abc;
 else
    dbms_output.put_line('division of two numbers = '||(x/y));
 end if;
Exception
 when ABC then
  raise_application_error(-20002, 'Divisor should not be equals to 0 ');
End;
/

Enter value for x: 90
Enter value for y: 6
division of two numbers = 15

PL/SQL procedure successfully completed.

SQL> /
Enter value for x: 90
Enter value for y: 0
declare
*
ERROR at line 1:
ORA-20002: Divisor should not be equals to 0
ORA-06512: at line 13

III. NON-PRE-DEFINED EXCEPTIONS :
---------------------------------

  -> These exceptions are used to handle constraint voilated error messages

  -> To write Non Pre-defined exception programs user must know ERROR CODES

  -> In this exceptions...

          i. Exception Name is defined by User

         ii. Activated by Oracle

        iii. Solution is provided by user

PRAGMA EXCEPTION_INIT :
-----------------------

  -> It is also one of the oracle pre-defined procedure

  -> this procedure main functionality USER DEFINED EXCEPTION NAME is associated with ORACLE ERROR      CODE

syn:- PRAGMA EXCEPTION_INIT( user-defined_exception_name, Oracle_error_code);


-- write a program to handle unique constraint error message

declare
 duplicates_found exception;
 pragma exception_init( duplicates_found, -00001);
Begin
  insert into dept values( 40, 'maths', 'hyd' );
Exception
  when duplicates_found then
    raise_application_error(-20003, 'Given Deptno. Already Exists...');
End;
/

declare
*
ERROR at line 1:
ORA-20003: Given Deptno. Already Exists...
ORA-06512: at line 8


-- Pl/sql block for to handle NOT NULL Constraint Voilated error message

declare
 nulls_found exception;
 pragma exception_init( nulls_found, -01400);
Begin
 Insert into dept values( null, 'maths', 'hyd' );
exception
 when nulls_found then
   raise_application_error(-20001, 'Dept. Column Value is Mandatory!!!!!'); 
end;
/

declare
*
ERROR at line 1:
ORA-20001: Dept. Column Value is Mandatory!!!!!
ORA-06512: at line 8

OTHERS :
---------

  -> It is one of the pre-defined exception name

  -> In Exception Block, if there is no Matching Exception names then by default OTHERS executed

  -> It is also called as DEFAULT Exception Name

** PL/SQL provides two pre-defined Functions

       i. SQLCODE : returns currently raising error code

      ii. SQLERRM : returns currently raising error message

ex:-

declare
 v_ename emp.ename%type;
begin
 select ename into v_ename from emp;
 dbms_output.put_line( v_ename );
exception
 when no_data_found then
   raise_application_error(-20002, 'Employ record Not found.');
 when others then
   dbms_output.put_line('default exception is raised.');
   dbms_output.put_line('Raising Error code : ' ||sqlcode);  
   dbms_output.put_line('Raising Error Msg  : ' ||sqlerrm);
end;
/

default exception is raised.
Raising Error code : -1422
Raising Error Msg  : ORA-01422: exact fetch returns more than requested number of rows

PL/SQL procedure successfully completed.


NAMED BLOCKS :
--------------
 
  -> A set of pl/sql programs stored in db permanently is called as Named Blocks

  -> All Named Block Programs are start with 'CREATE' command

          ex: Procedures ,Functions, Packages & Triggers

SUB-PROGRAMS :
--------------

  -> Sub-programs are Named Block Programs

  -> Sub-programs are supports Parameters

  -> Sub-programs are also supports Parameter modes ( IN, OUT, IN OUT )

  -> Sub-programs main advantage are...

  i. modularity :
  ---------------

      -> A huge program is devided into sub-program

      adv. 

       -> easy to understand

       -> easy to debug the errors

  ii. re-usability :
  ------------------

     -> Once Sub-program is created then it stores in ROWS and COLUMNS format so, we can execute the program
        'n' no.of times
 
  iii. Improves the performance :
  -------------------------------

     -> Sub-programs are stored in Compiled Format, that is sub-programs are compiled only one time

  iv. security :
  --------------

     -> Only authorized people can execute the sub-programs

 -> All created sub-programs are stored USER_OBJECTS TABLE (pre-defined tabel)

 -> All created sub-program bodies are stored in USER_SOURCE table ( pre-defined table ) 

 -> Sub-programs are two types

        i. Stored Procedures

      ii.  User-defined functions

i. Stored Procedures :
----------------------

  -> A set of pl/sql statements stored in db permanently and performs a task
  
  -> While calling procedures it supports parameters that is called as Procedure with Parameters

  -> Stored procedures are supports parameter modes IN, OUT & INOUT

  -> Stored Procedures are used to Manipulation purpose

  -> All created stored procedure names are stored in USER_OBJECTS and BODIES are stored in USER_SOURCE table

syn:-

Create or Replace Procedure <Procedure_name>
[( arg1 mode datatype, arg2 mode datatype,..)]
                  As
 [<Variable-declaration>;]
Begin
  <exec-statements>;
[Exception
  <Exec-statements>;]
End [<procedure_name>];
/

-- write a stored procedure to display welcome message

Create or replace procedure my_proc
                AS
Begin
  dbms_output.put_line('Welcome to Stored Procedures...');
End my_proc;
/

How to call the procedures:
---------------------------

on sql prompt :
---------------

exec <procedure_name>;

Ex:-

Exec my_proc;
Welcome to Stored Procedures...

PL/SQL procedure successfully completed.

ex:-

using pl/sql block :
--------------------

BEGIN
  <procedure_name>;
END;
/

ex:-
begin
  my_proc;
end;
/

Welcome to Stored Procedures...

PL/SQL procedure successfully completed.

-- write a stored procedure to find sum of two numbers

create or replace procedure add_proc 
              is
 x number(4) := 100;
 y number(4) := 500;
begin
  dbms_output.put_line( 'sum of two numbers = '||(x+y));
end add_proc;
/

SQL> exec add_proc;
sum of two numbers = 600

PL/SQL procedure successfully completed.

SQL> exec add_proc;
sum of two numbers = 600

PL/SQL procedure successfully completed.

SQL> exec add_proc;
sum of two numbers = 600

PL/SQL procedure successfully completed.


note: To execute above program returns same output, because Procedures are compiled only ONE TIME, to overcome       this problem to write procedures using Parameters
 
PROCEDURES using Parameters :
-----------------------------

  -> While calling the procedures to pass parameter values is called as Procedure with Parameters

  -> Maximum 32 parameters are supported

-- write a stored procedure to find sum of two given numbers

create or replace procedure add_proc
    ( x number, y number )
             is
Begin
 dbms_output.put_line('sum of two numbers = '||(x+y));
end add_proc;
/

calling procedure :
-------------------

SQL> exec add_proc(10, 40 ) ;

PL/SQL procedure successfully completed.

SQL> set serveroutput on
SQL> set verify off

SQL> exec add_proc(10, 40 ) ;
sum of two numbers = 50

PL/SQL procedure successfully completed.

SQL> exec add_proc(100, 400 ) ;
sum of two numbers = 500

PL/SQL procedure successfully completed.

-- write a stored procedure to input employee no. and display correponding employee record

Create or replace procedure emp_rec_proc
       ( p_empno emp.empno%type )
                     is
 e emp%rowtype;
begin
  select * into e from emp where empno=p_empno;
  dbms_output.put_line( e.empno||' '||e.ename||' '||e.job||' '||e.hiredate||' '
								||e.sal||' '||e.deptno); 
exception
 when no_data_found then
   raise_application_error(-20001, 'Employ record Not Found.');
end emp_rec_proc;
/

calling procedure :
-------------------

SQL>  exec emp_rec_proc( 7788 );
7788 SCOTT ANALYST 09-DEC-82 3100 20

PL/SQL procedure successfully completed.

SQL>  exec emp_rec_proc( 9000 );
BEGIN emp_rec_proc( 9000 ); END;

*
ERROR at line 1:
ORA-20001: Employ record Not Found.
ORA-06512: at "ORA7AM.EMP_REC_PROC", line 11
ORA-06512: at line 1


Procedures using INSERT command :
---------------------------------

create or replace procedure Ins_proc
( p_deptno dept.deptno%type,
  p_dname dept.dname%type,
  p_loc dept.loc%type )
             as
begin
  insert into dept values ( p_deptno, p_dname, p_loc );
  dbms_output.put_line('record inserted');
end ins_proc;
/

SQL> exec ins_proc( 50, 'maths', 'hyd' );
record inserted

PL/SQL procedure successfully completed.

SQL> select * from dept;

DEPTNO DNAME          LOC
------ -------------- -------------
    10 ACCOUNTING     NEW YORK
    20 RESEARCH       DALLAS
    30 SALES          CHICAGO
    40 OPERATIONS     BOSTON
    50 maths          hyd

Procedures using UPDATE command :
---------------------------------

  -- write a stored procedure to increment employee salary based on given PCT.

  Create or replace procedure upd_proc
( p_empno emp.empno%type, p_pct number )
                  is
begin
 update emp set sal = sal + sal * p_pct/100 where empno = p_empno;
 if sql%found then
    dbms_output.put_line('record updated');
 else
    dbms_output.put_line('No Record Found.');
 end if;
End upd_proc;
/

         
calling procedure :
-------------------

SQL> exec upd_proc( 7902, 10 );
record updated

PL/SQL procedure successfully completed.

SQL> exec upd_proc( 9000, 10 );
No Record Found.

PL/SQL procedure successfully completed.


Procedure using DELETE command :
--------------------------------

Create or replace procedure Delete_proc
 ( p_empno emp.empno%type )
              as
begin
 delete from emp where empno=p_empno;
 if sql%found then
    dbms_output.put_line('Record Deleted');
 else
    dbms_output.put_line('Employ Record Not Found.');
 end if;
End;
/

SQL> exec delete_proc(7788);
Record Deleted

PL/SQL procedure successfully completed.

SQL> exec delete_proc(9000);
Employ Record Not Found.

PL/SQL procedure successfully completed.

Procedures using Parameter Modes :
----------------------------------

  -> Procedures are supports 3 types of parameter modes

         i. IN

        ii. OUT

       iii. IN OUT

i. IN :
--------

  -> this parameter mode is used to taking input into Procedure

  -> By default all parameter modes are IN

  -> On IN parameter mode variables Assignment Targets( := ) are not supported

ex:-

create or replace procedure add_proc
    ( x in number, y in number )
             is
Begin
 dbms_output.put_line('sum of two numbers = '||(x+y));
end add_proc;
/

  
** On IN parameter mode variables Assignment Targets( := ) are not supported**:
******************************************************************************

create or replace procedure add_proc
    ( x in number, y in number )
             is
Begin
  x:= x + 10;
 dbms_output.put_line('sum of two numbers = '||(x+y));
end add_proc;
/

Warning: Procedure created with compilation errors.

SQL> show errors
Errors for PROCEDURE ADD_PROC:

LINE/COL ERROR
-------- -----------------------------------------------------------------
5/3      PL/SQL: Statement ignored
5/3      PLS-00363: expression 'X' cannot be used as an assignment target


ii. OUT :
---------
  
  -> Procedures are may or may not return values
  
  -> Procedures are return values through OUT parameter mode variables

  -> On OUT parameter mode variable assignment targets are supported


ex:-
 
  -- write a stored procedure to input two numbers and returns sum of two numbers

   Create or replace procedure add_proc
 ( x in number, y in number, z out number )
                      is
   Begin
     z := x + y;
   End add_proc;
/

calling procedure :
-------------------

on sql prompt :
---------------

sql> variable res number;
sql> exec add_proc( 100, 200, :res );
sql> print :res;


note: To declare variables on SQL PROMPT those variables are called as BIND / GLOBAL Variables.  
      These variables scope is session valid. Sql variables are represented with preceeding ':'  operator.

USING PL/SQL BLOCK :
--------------------

declare
 result number;
begin
 add_proc(100,200,result);   -- calling procedure
 dbms_output.put_line( result );
End;
/


-- write a stored procedure to input employee no. and return corresponding employee job

Create or replace procedure emp_proc
( p_empno in emp.empno%type,
  p_job out emp.job%type )
            is
begin
  select job into p_job from emp where empno = p_empno;
End emp_proc;
/
 
CALLING procedure :
-------------------
declare
 v_job emp.job%type;
begin
 emp_proc( &empno, v_job );
 dbms_output.put_line( v_job );
end;
/
Enter value for empno: 7839
PRESIDENT

PL/SQL procedure successfully completed.

-- write a procedure to input employee no. and return

Procedure:
----------

Create or replace procedure emp_find
( p_empno in emp.empno%type,
  p_ename out emp.ename%type,
  p_job out emp.job%type,
  p_sal out emp.sal%type,
  p_deptno out emp.deptno%type
)
             is
begin
  select ename, job, sal, deptno into p_ename, p_job, p_sal, p_deptno 
					from emp where empno = p_empno; 
End emp_find;
/
 
calling procedure :
-------------------
declare
 v_empno emp.empno%type := &empno;     -- 7902
 v_ename emp.ename%type;
 v_job emp.job%type;
 v_sal emp.sal%type;
 v_deptno emp.deptno%type;
Begin
  emp_find( v_empno, v_ename, v_job, v_sal, v_deptno );
  dbms_output.put_line( v_empno ||' '||v_ename||' '||v_job||' '||v_sal||' '||v_deptno);
End;
/

Enter value for empno: 7902
7902 FORD ANALYST 3410 20

PL/SQL procedure successfully completed.

SQL> /
Enter value for empno: 7521
7521 WARD SALESMAN 1350 30

PL/SQL procedure successfully completed.


-- write a stored procedure to create a new user account

** create a user details table with user id, user name, password and role

Table creation:
--------------
Create table user_details
( user_id number(4),
  user_name varchar(15),
  password varchar(15),
  role varchar(10)
);



validations:
------------

  -> user id should be generate automatically

  -> Enter and conf. passwords should be same

  -> min. length of password is 6 chars.

  -> role should be accepts admin, employee, customer

  -> and returns status

Sequence for to generate USER IDs :
-----------------------------------

Create sequence user_id_seq
start with 1
increment by 1;

Procedure :
-----------

Create or replace procedure user_reg_proc
( p_user_name in User_details.user_name%type,
  p_password  in User_details.password%type,
  p_cnf_password in  user_details.password%type,
  p_role in user_details.role%type,
  p_status out varchar2  ) 
             is
  Begin
    if length(p_password)<6 then
       P_STATUS := 'Min. length of password is 6 characters.' ;
    elsif p_password != p_cnf_password then   
       p_status := 'Enter and Cnf. passwords should be same';     
    elsif p_role not in ( 'admin','employ','customer') then
       p_status := 'Invalid Role....';
    else 
       insert into user_details values ( user_id_seq.nextval,
					 p_user_name,
                                         p_password,
                                         p_role );
       p_status := 'User created successfully';
    end if;
  End user_reg_proc;
/

Calling procedure :
-------------------

declare
 status varchar(100);
begin
 user_reg_proc('king','king123','king123','admin',status);    -- calling procedure
 dbms_output.put_line( status );
End;
/

declare
 status varchar(100);
begin
 user_reg_proc('scott','scott123','scott123','employ',status);    -- calling procedure
 dbms_output.put_line( status );
End;
/

SQL> select * from user_details;

USER_ID USER_NAME       PASSWORD        ROLE
------- --------------- --------------- ----------
      1 king            king123         admin
      2 scott           scott123        employ

Invalid data :
--------------

declare
 status varchar(100);
begin
 user_reg_proc('&username','&password','&cnf_password','&role',status);    -- calling procedure
 dbms_output.put_line( status );
End;
/

Enter value for username: smith
Enter value for password: smith
Enter value for cnf_password: smith
Enter value for role: admin
Min. length of password is 6 characters.

PL/SQL procedure successfully completed.

SQL> /
Enter value for username: smith
Enter value for password: smith123
Enter value for cnf_password: smith
Enter value for role: admin
Enter and Cnf. passwords should be same

PL/SQL procedure successfully completed.

SQL> /
Enter value for username: smith
Enter value for password: smith123
Enter value for cnf_password: smith123
Enter value for role: guest
Invalid Role....

PL/SQL procedure successfully completed.

SQL> select * from user_details;

USER_ID USER_NAME       PASSWORD        ROLE
------- --------------- --------------- ----------
      1 king            king123         admin
      2 scott           scott123        employ

-- write a stored procedure to input username, password and return status

Create or replace procedure Login_Proc
( p_user_name In user_details.user_name%type,        -- king
  p_password In user_details.password%type,          -- king 
  p_status Out Boolean
)
                   Is
 cnt number;
Begin
 select count(*) into cnt from user_details 
					where user_name=p_user_name
							and
					      password = p_password;
  if cnt = 1 then
     p_status := true;
  else
     p_status := false;
  end if;
End login_proc;
/

calling procedure :
-------------------

declare
  flag boolean;
Begin
  login_proc( '&user_name', '&password', flag );       -- calling procedure
  if flag=true then
     dbms_output.put_line('Login Successfully.'); 
  else
     dbms_output.put_line('Invalid UserName/Password'); 
  end if;
End;
/

Enter value for user_name: king
Enter value for password: king123
Login Successfully.

PL/SQL procedure successfully completed.

SQL> /
Enter value for user_name: king
Enter value for password: king
Invalid UserName/Password

PL/SQL procedure successfully completed.


** Procedures returns a record **:
----------------------------------

  -> Procedure returns a record out parameter should be %ROWTYPE attribute datatype

-- Procedure for to input employee no and return corresponding employee record

Create or replace procedure emp_rec
 ( p_empno in emp.empno%type,
   p_rec out emp%rowtype
 )
             is
Begin
  select * into p_rec from emp where empno = p_empno;
End emp_rec;
/

calling procedure :
-------------------

declare
 e emp%rowtype;
begin
 emp_rec( &empno, e );
 dbms_output.put_line( e.empno ||' '||e.ename||' '||e.job||' '||e.mgr||' '||e.hiredate||' '||e.sal||' '||
                       e.comm||' '||e.deptno );
End;
/

Enter value for empno: 7839
7839 KING PRESIDENT  17-NOV-81 5100  10

PL/SQL procedure successfully completed.

SQL> /
Enter value for empno: 7521
7521 WARD SALESMAN 7698 13-FEB-22 1350 500 30

PL/SQL procedure successfully completed.

Procedures with Default Arguments :
----------------------------------

  -> While calling the procedure if we are not passing any value to parameters then by default procedures are      taking specified default values.

ex:-

  -- stored procedure for to insert data into dept. table

Create or replace procedure dept_ins
( p_deptno in  dept.deptno%type,
  p_dname in dept.dname%type default 'Unknown',
  p_loc in dept.loc%type default 'Unknown' )
            is
Begin
  insert into dept values ( p_deptno, p_dname, p_loc );
  dbms_output.put_line('record inserted');
end dept_ins;
/

calling procedure :
-------------------

SQL> Exec dept_ins( 50, 'maths' );
record inserted

PL/SQL procedure successfully completed.

SQL> select * from dept;

DEPTNO DNAME          LOC
------ -------------- -------------
    10 ACCOUNTING     NEW YORK
    20 RESEARCH       DALLAS
    30 SALES          CHICAGO
    40 OPERATIONS     BOSTON
    50 maths          Unknown

SQL> Exec dept_ins( 60, 'hyd' );
record inserted

PL/SQL procedure successfully completed.

SQL> select * from dept;

DEPTNO DNAME          LOC
------ -------------- -------------
    10 ACCOUNTING     NEW YORK
    20 RESEARCH       DALLAS
    30 SALES          CHICAGO
    40 OPERATIONS     BOSTON
    50 maths          Unknown
    60 hyd            Unknown

6 rows selected.

note: In above execute Dept.Name taken as 'hyd' and loc taken as 'unknown' because by default procedures       calling according corresponding positions.  To over come this problem Procedures supports NOTATIONS

NOTATIONS :
-----------

   -> while calling the procedures to pass parameter values according to corresponding parameter possitions or       by using formal argument names 

   -> there are three types of notations

         i. positional notations

        ii. named notations

       iii. mixed notations

i. positional notations:
------------------------

  -- while calling the procedure to pass paremeter values according to corresponding parameter positions is      called as Positional notations.  By defualt we calling this method

ex:-  Exec dept_ins( 50, 'maths', 'hyd' );

ii. Named Notations :
---------------------

  -- While calling the procedures to pass paremeter values by using formal argument names is called as Named         Notations.

ex:-  exec dept_ins( p_dname=> 'maths', p_loc=> 'hyd', p_deptno=> 50 );


iii. Mixed Notations :
----------------------

  -> both positional and named notations are called as Mixed Notations

ex:-

SQL> Exec dept_ins( 50, P_LOC=>'hyd' );
record inserted

PL/SQL procedure successfully completed.

SQL> select * from dept;

DEPTNO DNAME          LOC
------ -------------- -------------
    10 ACCOUNTING     NEW YORK
    20 RESEARCH       DALLAS
    30 SALES          CHICAGO
    40 OPERATIONS     BOSTON
    50 Unknown        hyd

** To see the created procedure names

SQL>  select object_name from user_objects where object_type='PROCEDURE';

OBJECT_NAME
----------------------------------------------------------------------------------------------------
MY_PROC
ADD_PROC
EMP_REC_PROC
INS_PROC
UPD_PROC
DELETE_PROC
EMP_PROC
EMP_FIND
USER_REG_PROC
LOGIN_PROC
EMP_REC
DEPT_INS

12 rows selected.

** to see the particular procedure body

SQL> select text from user_source where name='LOGIN_PROC';

TEXT
----------------------------------------------------------------------------------------------------
procedure Login_Proc
( p_user_name In user_details.user_name%type,        -- king
  p_password In user_details.password%type,          -- king
  p_status Out Boolean
)
                   Is
 cnt number;
Begin
 select count(*) into cnt from user_details
where user_name=p_user_name
and
      password = p_password;
  if cnt = 1 then
     p_status := true;
  else
     p_status := false;
  end if;
End login_proc;

18 rows selected.

** Dropping procedures 

syn:- 

 Drop procedure <procedure_name>;

ex:- 

  Drop Procedure my_proc;


II. USER-DEFINED FUNCTIONS :
----------------------------

  -> According to Client requirement developer write with his own function and logic is called as user defined       functions.

  -> Function is also a sub-program
  
  -> Functions should be return a value by using RETURN statement

  -> Functions are supports parameters and parameter modes

  -> All created function names are stored in USER_OBJECTS and Function Bodies are stored in USER_SOURCE tables

syn:-

Create or replace function <function_name>
[(arg1 mode datatype, arg2 mode datatype...)]
            return datatype
                    is
 [<variable-declaration>;]
Begin
  <exe-statements>;
  Return( value );
[Exception
  <exec-statements>;
  Return( value );]
End [<function_name>];

Example:
--------

  -- write a user defined find simple interest

          si = ptr/100

Create or replace function si( p number, t number, r number )
                        return number
                              is
 interest number;
Begin
  interest := P * T * ( R / 100 );
  Return( interest );
End si;
/

To call User defined functions different methods provided by ORACLE :
---------------------------------------------------------------------

ON SQL PROMPT :

method1 :
---------

SQL> select si(1000,2,10) from dual;

SI(1000,2,10)
-------------
          200

method2:
--------

SQL> variable res number;
SQL> exec :res := si(1000,2,10);

PL/SQL procedure successfully completed.

SQL> print :res;

   RES
------
   200

Using PL/SQL Block :
--------------------

method 3 :
----------

declare
  result number;
begin
  select si(1000,2,10) into result from dual;
  dbms_output.put_line('simple interest = '||result);
end;
/

simple interest = 200

PL/SQL procedure successfully completed.

method 4:
---------

declare
 result number;
begin
 result := si(1000,2,10);
 dbms_output.put_line('simple interest = '||result);
end;
/
simple interest = 200

PL/SQL procedure successfully completed.

method 5:
---------

begin
  dbms_output.put_line('simple interest = '||si(1000,2,10));
end;
/
simple interest = 200

PL/SQL procedure successfully completed.

-- write a user defined function to input employee no. and returns corresponding employee dept. name.

create or replace function emp_dname
( p_empno emp.empno%type )
Return varchar2
is
 v_dname varchar(20);
begin
 select dname into v_dname from dept 
				where deptno=( select deptno from emp where empno=p_empno);
 return( v_dname );
End emp_dname;
/

calling function :
------------------

SQL> select emp_dname(7839) from dual;

EMP_DNAME(7839)
------------------------------------------------------------------ 
ACCOUNTING

-- write a user defined function to find given employee experience

create or replace function emp_exp( p_empno emp.empno%type )
return number
is
 v_exp number;
begin
 select round( months_between(sysdate, hiredate)/12, 1) into v_exp from emp
							where empno = p_empno;
 return( v_exp );
end emp_exp;
/

SQL> select emp_exp(7839) from dual;

EMP_EXP(7839)
-------------
         40.3

Function returns BOOLEAN value :
--------------------------------

  -- write a user defined function to find given employe record found or not

Create or replace function emp_find( p_empno emp.empno%type)
return boolean
is
 cnt number;
begin
 select count(*) into cnt from emp where empno=p_empno;
 if cnt > 0 then
    return(true);
 else
    return(false);
 end if;
end emp_find;
/

calling function :
------------------

SQL> select emp_find(7839) from dual;
select emp_find(7839) from dual
       *
ERROR at line 1:
ORA-06552: PL/SQL: Statement ignored
ORA-06553: PLS-382: expression is of wrong type

note: if function type is BOOLEAN then that function is not executed on SQL Prompt because SQL not supported          BOOLEAN datatype.  So, to execute above function we can write another PL/SQL Block.

ex:-

Begin
 if emp_find( &empno ) = true then
    dbms_output.put_line('employ record found.');
 else 
    dbms_output.put_line('employ not record found.');
 end if;
End;
/

Enter value for empno: 7839
employ record found.

PL/SQL procedure successfully completed.

SQL> /
Enter value for empno: 9000
employ not record found.

PL/SQL procedure successfully completed.

** PROGRAM for to use Procedures, Functions & cursors ** :
----------------------------------------------------------

-- write a stored procedure to increment all employee salaries based on following conditions.

        if employee experience >=10 years then 40% increment

        if employee experience is <10 years then 30% increment

 and incremented details should be stored in employee audit table 

table creation:
---------------
 
 Create table emp_audit( empno number(4), experience number(5,2), incr_sal number(8,2) );

Create or replace procedure emp_incr_proc
                is
 cursor e_cur is select empno, sal from emp;
 e e_cur%rowtype;
 expe number;
 incr_sal number;
Begin
 open e_cur;
 loop
  fetch e_cur into e;
  exit when e_cur%notfound;
  expe := emp_exp(e.empno);    -- calling function
  if expe >=10 then
      incr_sal := e.sal * 0.4;
  elsif expe <10 then
      incr_sal := e.sal * 0.3;
  end if;
  update emp set sal = sal + incr_sal where empno = e.empno;
  Insert into emp_audit values ( e.empno, expe, incr_sal );
 End loop;
 close e_cur;
 dbms_output.put_line( 'salaries incremented successfully.');
End;
/

CALLING PROCEDURE :
-------------------

SQL> exec emp_incr_proc;

SQL> SELECT * FROM EMP_AUDIT;

 EMPNO EXPERIENCE INCR_SAL
------ ---------- --------
  7369       41.2      320
  7499       41.1      640
  7521         41      500
  7566       40.9     1190
  7654       40.4      500
  7698       40.9     1140
  7782       40.7      980
  7788       39.2     1200
  7839       40.3     2000
  7844       40.5      600
  7876       39.2      440
  7900       40.3      380
  7902       40.3     1200
  7934       40.1      520

14 rows selected.

PACKAGES :
----------

 -> Package is a collection of Variables, Cursors, Procedures and Functions

 -> Packages are used to Improves the performance while Accessing sub-programs from client location

 -> Packages are not supported Parameters and Packages doesn't return any value

 -> All Created Package Names are stored in USER_OBJECTS and PACKAGE Bodies are stored in USER_SOURCE.

 -> Basically Packages are two types

I. PRE-DEFIEND PACKAGES

II. USER-DEFINED PACKAGES

I. PRE-DEFINED PACKAGES:
------------------------

  -> These packages are defined by ORACLE

           ex: dbms_output, utl_files, etc.,

II. USER-DEFINED PACKAGES :
---------------------------

  -> These packages are defined user Explicitely

  -> User defined packages contains two parts

           i. Package Specification

          ii. Package Body

i. Package Specification :
--------------------------

  -> It contains declaration of Variables, cursors, procedures & functions

ii. Package Body :
------------------

  -> It contains body of package specification

Example :
---------

-- write a package program to find given employee netsalary(procedure) and to find grade(function)

Package Specification:
----------------------

Create or replace Package emp_pack
              is
 Procedure emp_netsal( p_empno emp.empno%type );
 Function  emp_grade ( p_empno emp.empno%type) return number;
End emp_pack;
/

Package Body :
--------------

Create or replace package body emp_pack
                      As
 Procedure emp_netsal( p_empno emp.empno%type ) 
                    is
  v_netsal number(7,2);
 Begin
  select sal + nvl(comm,0) into v_netsal from emp
					where empno = p_empno;
  dbms_output.put_line( 'Given Employee Net Salary Rs.'||v_netsal);
 End Emp_Netsal;

 Function emp_grade( p_empno emp.empno%type ) Return Number
                          is
  v_grade number(2);
 Begin
  select grade into v_grade from emp, salgrade 
				where sal between losal and hisal
						and
					    empno = p_empno;
  return( v_grade );
 End emp_grade;
End emp_pack;
/

calling package :
-----------------

SQL> exec emp_pack.emp_netsal(7788);
Given Employee Net Salary Rs.4200

PL/SQL procedure successfully completed.

SQL> select emp_pack.emp_grade( 7788 ) from dual;

EMP_PACK.EMP_GRADE(7788)
------------------------
                       5

** Packages are supports Function OverLoading :
-----------------------------------------------

  -> Function Name is same and it supports Different types or No.of Parameters is called as Function      Overloading.
             
  -> Only Packages are supports Function Overloading and it is one of the OOPs feature

Package Specification :
-----------------------

Create or replace package fo_pack
             is
 function addval( x number, y number ) return number;
 function addval( x number, y number, z number) return number;
 function addval( str1 varchar2, str2 varchar2) return varchar2;
End fo_pack;
/

Package body :
--------------

Create or replace package body fo_pack
             is
 function addval( x number, y number ) return number
                      is
 begin
  return( x + y );
 end addval;

 function addval( x number, y number, z number) return number
                              is
 begin
  return( x + y + z );
 end addval;

 function addval( str1 varchar2, str2 varchar2) return varchar2
                              is
 begin
   return ( str1 ||' '|| str2 );
 end addval;
End fo_pack;
/

SQL> select fo_pack.addval(10,20, 30 ) from dual;

FO_PACK.ADDVAL(10,20,30)
------------------------
                      60

SQL> select fo_pack.addval(10, 30 ) from dual;

FO_PACK.ADDVAL(10,30)
---------------------
                   40

SQL> select fo_pack.addval('naresh', 'it' ) from dual;

FO_PACK.ADDVAL('NARESH','IT')
----------------------------------------------------------------------------------------------------
naresh it

** Packages using REF CURSORS :
-------------------------------

 -- write a procedure to return who are working given deptnos.

Package specification :
-----------------------

Create or replace package P1
             is
 Type r_cur is ref cursor;
End P1;
/

Procedure :
-----------

Create or replace procedure emp_recs
( p_deptno in emp.deptno%type,
  p_cur out P1.r_cur )
          is
begin
 open p_cur for select * from emp where deptno= p_deptno;
End emp_recs;
/

calling Procedure :
-------------------

Declare
 v_cur p1.r_cur;
 e emp%rowtype;
begin
 emp_recs( &deptno, v_cur );     -- calling procedure
 loop
   fetch v_cur into e;
   exit when v_cur%notfound;
   dbms_output.put_line( e.empno||' '||e.ename||' '||e.job||' '||e.sal||' '||e.deptno);
 End Loop;
End;
/

Enter value for deptno: 10
7782 CLARK MANAGER 2450 10
7839 KING PRESIDENT 5000 10
7934 MILLER CLERK 1300 10

PL/SQL procedure successfully completed.

SQL> /
Enter value for deptno: 20
7369 SMITH CLERK 800 20
7566 JONES MANAGER 2975 20
7788 SCOTT ANALYST 3000 20
7876 ADAMS CLERK 1100 20
7902 FORD ANALYST 3000 20

PL/SQL procedure successfully completed.

** to see the created package names

   select object_name from  user_objects where object_type='PACKAGE';

** to see the created package body

   select text from user_source where name='P1';

** dropping packages

    Drop Package my_pack;

TRIGGERS :
----------

  -> It is one the ORACLE Named Block Program

  -> A set of Pl/sql statements stored permanently in DB and automaticlaly activated whenever an Event Raising       Statement is performed.

  -> Generally triggers are Activated whenever DML operations are performed

  -> Triggers are also activated when the tables are manipulated by other users or by other application      software tools.

  -> Triggers are used to restrict user defined conditions or business rules

  -> All created trigger names are stored in USER_TRIGGERS and Trigger Bodies are stored in USER_SOURCE table

Trigger Parts :
---------------

i. Trigger Event :
------------------

  -> It indicates when to activate the trigger

  -> Trigger supports 6 types of events

         a. Before Insert
         b. Before Update
         c. Before Delete
         d. After Insert
         e. After Update
         f. After Delete

ii. Trigger type :
------------------

  -> It indicates type of the trigger

  -> there are two types triggers

          i. Row level Trigger

         ii. Statement Level or Table Level Triggers

iii. Trigger restriction :
--------------------------

  -> It is used to Stop Automatic Execution of Code 

iv. Trigger Body :
------------------

  -> A set of pl/sql statements

syn:-

Create or replace trigger <trigger_name>
Before/After Insert or Update or Delete   -- I
[of Columns] ON <table_name>
[For Each Row]                   -- II
[When <condition>]         -- III
[Declare
  <variable-declaration>;]
Begin
  <Exec-statements>;              -- IV
[Exception
  <Exec-statements>;]
End;
/

** To perform any DML commands on DB tables first data will be stored in ROLLBACK segment.

ex:-

dept:          -- step3
-----
50	maths	hyd


rollback segment :        -- step2
------------------

:deptno=50    :dname=maths    :loc=hyd


SQL> Insert into dept values ( 50, 'maths', 'hyd' );         -- step1


** Triggers are supports two types of Access Specifiers

   i. New      ii. Old

** these access specifiers are placed preceeding Rollback segment columns based on the trigger event

            ex: new.deptno,  :old.deptno

   Before Insert
   Before Update
   Before Delete	:NEW.
   After Insert
   After Update

   After Insert
   After Update		:OLD.
   After Delete   
	

-- Write a trigger program to insert data into dept. table and Dept. Name should be stored with    Capital Letters automatically in DEPT. table

step3:

Create or replace trigger dept_trig
Before Insert on dept
for each row
begin
 :new.dname := upper( :new.dname );
end;
/

dept   -- step 4
----
deptno	dname	loc
 50	MATHS	hyd

step2: 
rollback segment:
-----------------
:deptno=50    :dname=MATHS    :loc = hyd

Testing :
---------

SQL> Insert into dept values ( 50, 'maths', 'hyd' );   -- step1

1 row created.

SQL> select * from dept;

DEPTNO DNAME          LOC
------ -------------- -------------
    10 ACCOUNTING     NEW YORK
    20 RESEARCH       DALLAS
    30 SALES          CHICAGO
    40 OPERATIONS     BOSTON
    50 English        sec
    50 MATHS          hyd

6 rows selected.

eX2:-

-- Write a trigger program to restrict employ record if updated salary is < existing salary

Create or replace trigger upd_trig
Before Update on emp
for each row
begin
  if :new.sal < :old.sal then
      raise_application_error( -20001, 'Updated Salary should be > Existing Salary.');
  end if;
end;

rollback segment :
------------------
:old.empno=7788, :old.ename=scott, :old.sal=3000, .... :old.deptno=20

:new.empno=7788, :new.sal=2000



SQL> Update emp set sal = 2000 where empno=7788;


testing:
--------

SQL> update emp set sal=2000 where empno=7788;
update emp set sal=2000 where empno=7788
       *
ERROR at line 1:
ORA-20001: Updated Salary should be > Existing Salary.
ORA-06512: at "ORA8PM.UPD_TRIG", line 3
ORA-04088: error during execution of trigger 'ORA8PM.UPD_TRIG'


SQL> update emp set sal=4000 where empno=7788;

1 row updated.


-- write a trigger program to take employee records backup.

Create a employee backup table with the same structure of EMP :
---------------------------------------------------------------

  Create table emp_backup as select * from emp where 1=2;


Create or replace trigger emp_backup_trig
After Delete on Emp
for each row
Begin
  Insert into emp_backup values ( :old.empno, :old.ename, :old.job,
				  :old.mgr, :old.hiredate, :old.sal, :old.comm, :old.deptno);
  dbms_output.put_line('backup taken successfully.');
End;
/

Rollback segment:  
:old.empno=7788, :old.ename=scott,...... :old.deptno=20


SQL> delete from emp where empno=7788;
backup taken successfully.

1 row deleted.

SQL> select * from emp;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7369 SMITH      CLERK       7902 17-DEC-80    800            20
  7499 ALLEN      SALESMAN    7698 20-FEB-81   1600    300     30
  7521 WARD       SALESMAN    7698 22-FEB-81   1250    500     30
  7566 JONES      MANAGER     7839 02-APR-81   2975            20
  7654 MARTIN     SALESMAN    7698 28-SEP-81   1250   1400     30
  7698 BLAKE      MANAGER     7839 01-MAY-81   2850            30
  7782 CLARK      MANAGER     7839 09-JUN-81   2450            10
  7839 KING       PRESIDENT        17-NOV-81   5000            10
  7844 TURNER     SALESMAN    7698 08-SEP-81   1500      0     30
  7876 ADAMS      CLERK       7788 12-JAN-83   1100            20
  7900 JAMES      CLERK       7698 03-DEC-81    950            30
  7902 FORD       ANALYST     7566 03-DEC-81   3000            20
  7934 MILLER     CLERK       7782 23-JAN-82   1300            10

13 rows selected.

SQL> select * from emp_backup;

 EMPNO ENAME      JOB          MGR HIREDATE     SAL   COMM DEPTNO
------ ---------- --------- ------ --------- ------ ------ ------
  7788 SCOTT      ANALYST     7566 09-DEC-82   4000            20


ex:-

  -- write a trigger program to perform DML commands on EMP table status should be stored in EMPLOYEE AUDIT Table

Table creation :
----------------

Create table employ_status
( empno number(4),
  sdate date,
  status varchar(40) 
);

Trigger :
---------
Create or replace trigger EMP_DML_TRIG
After Insert or Update or Delete
on Emp
for each row
Begin
 if INSERTING then
     insert into employ_status values ( :new.empno, sysdate, 'New employee recruited');
 elsif UPDATING then
     insert into employ_status values ( :new.empno, sysdate, 'Employ record updated');
 elsif DELETING then
     insert into employ_status values ( :old.empno, sysdate, 'Employ removed from org.');
 end if;
End;
/

Testing :
---------
SQL> insert into emp ( empno, ename, sal,deptno ) values ( 1001, 'AAA', 5000, 10 );

1 row created.

SQL> Update emp set sal = 3000 where empno=1001;
Update emp set sal = 3000 where empno=1001
       *
ERROR at line 1:
ORA-20001: Updated Salary should be > Existing Salary.
ORA-06512: at "ORA8PM.UPD_TRIG", line 3
ORA-04088: error during execution of trigger 'ORA8PM.UPD_TRIG'


SQL> Update emp set sal = 5100 where empno=1001;

1 row updated.

SQL> delete from emp where empno=1001;
backup taken successfully.

1 row deleted.

SQL> select * from employ_status;

 EMPNO SDATE     STATUS
------ --------- ----------------------------------------
  1001 09-MAR-22 New employee recruited
  1001 09-MAR-22 Employ record updated
  1001 09-MAR-22 Employ removed from org.

II. Statement Level Triggers :
------------------------------

  -> Trigger body executes only once for ONE DML statement on entire table

  -> In Statement level trigger programs Trigger specifiers are not supported ( New and Old )


Ex:-

  -- write  a trigger program to restrict DML commands on EMP table based on the following conditions

             
          -> Office timings are 10am to 4pm

          -> Weekends Holidays

          -> On Public Holidays are also Holidays

Create a Public Holiday table with Holiday Dates :
--------------------------------------------------

Create table Holiday( Hdate date );

Insert into Holiday values ( '26-jan-22');
Insert into Holiday values ( '15-aug-22');
Insert into Holiday values ( '25-dec-22');

SQL> select * from holiday;

HDATE
---------
26-JAN-22
15-AUG-22
25-DEC-22

Trigger program :
-----------------

Create or replace trigger Holiday_Trig
Before Insert or Update or Delete
On Emp
Declare
 cnt number;
Begin
  if to_char(sysdate, 'hh24' ) not between 10 and 16 then
      raise_application_error(-20001, 'Off-timings, Trans. are not allowed.');
  end if;
  if to_char(sysdate, 'dy' ) in ( 'sat','sun') then
      raise_application_error(-20002, 'Week-ends, Trans. are not allowed.');      
  end if;
  select count(*) into cnt from Holiday where trunc(hdate)=trunc(sysdate);
  if cnt>0 then
     raise_application_error(-20003, 'Today Public Holiday, Trans. are Not Allowed.');
  end if;
End;
/

Testing:
-------- 
  
SQL> UPDATE EMP SET SAL = SAL + 100;
UPDATE EMP SET SAL = SAL + 100
       *
ERROR at line 1:
ORA-20001: Off-timings, Trans. are not allowed.
ORA-06512: at "ORA8PM.HOLIDAY_TRIG", line 5
ORA-04088: error during execution of trigger 'ORA8PM.HOLIDAY_TRIG'

III. DDL triggers :
-------------------

  -> To write triggers on DDL commands is called as DDL triggers

  -> DDL triggers are also called as SCHEMA LEVEL TRIGGERS

  -> DDL triggers are executed on Entire SCHEMA

SCHEMA :- Schema means User 

USER :- User contains collection of objects

Ex:-

  -- write a trigger program to restrict DROP command on DB OBJECTS

Create or replace trigger drop_trig
Before Drop on SCHEMA
begin
  raise_application_error(-20002, 'Access Denied!!!!!');
End;
/

SQL> drop table emp;
drop table emp
*
ERROR at line 1:
ORA-00604: error occurred at recursive SQL level 1
ORA-20002: Access Denied!!!!!
ORA-06512: at line 2


SQL> drop view my_view;
drop view my_view
*
ERROR at line 1:
ORA-00604: error occurred at recursive SQL level 1
ORA-20002: Access Denied!!!!!
ORA-06512: at line 2

Note: Once above trigger created we can drop any db objects.  if we want to drop then first we can drop             DROP_TRIG trigger then only we can drop other db objects.


INSTEAD OF TRIGGERS :
---------------------

 -> Generally we can write the trigger on tables but we can write the triggers on VIEWS also.

 -> To write triggers on views the trigger event is 'INSTEAD OF'

Example:
--------

Table creations:
----------------

Create table std_mas( std_id varchar(10), std_name varchar(10), class varchar(10) );

Create table std_marks( std_id varchar(10), maths number(6,2), phys number(6,2), chem number(6,2) );

create a complex view:
----------------------

Create or replace view std_comp_view
as
select s.std_id, s.std_name, s.class, sm.maths, sm.phys, sm.chem 
from std_mas s, std_marks sm
where s.std_id = sm.std_id;

inserting data into complex views :
-----------------------------------

SQL> insert into std_comp_view values ( 's1','xxx', 'xi', 90, 80, 80 );
insert into std_comp_view values ( 's1','xxx', 'xi', 90, 80, 80 )
*
ERROR at line 1:
ORA-01779: cannot modify a column which maps to a non key-preserved table


note: on complex views we can't insert the data, if we want to insert then INSTEAD OF TRIGGERS are supported

Trigger :
---------
Create or replace trigger std_comp_view_trig
INSTEAD OF INSERT ON STD_COMP_VIEW
FOR EACH ROW
BEGIN
 insert into std_mas values ( :new.std_id, :New.std_name, :new.class );
 insert into std_marks values ( :new.std_id, :New.maths, :new.phys, :new.chem );
END;
/

SQL> insert into std_comp_view values ( 's1','xxx', 'xi', 90, 80, 80 );

1 row created.

SQL> select * from std_mas;

STD_ID     STD_NAME   CLASS
---------- ---------- ----------
s1         xxx        xi

SQL> select * from std_marks;

STD_ID      MATHS   PHYS   CHEM
---------- ------ ------ ------
s1             90     80     80


DB LEVEL TRIGGERS :
-------------------
  
  -> these triggers are executed on LOGIN & LOGOFF Events


Example :
---------

  -- write a trigger program to main employee login details

Table creation :
----------------

Create table login_details
( user_id varchar(10),
  user_name varchar(10),
  login_time timestamp,
  logout_time timestamp
);

Login Trigger :
---------------

Create or replace trigger login_trig
After LOGON on SCHEMA
Begin
 insert into login_details values ( uid, user, sysdate, null );
End;
/

Testing :
---------

Step1: exit from the session

step2: login to ora8pm

step3: select * from login_details;


LOGOUT Trigger :
----------------

Create or replace trigger logoff_trig
BEFORE LOGOFF on SCHEMA
begin
  update login_details set logout_time=sysdate 
			WHERE login_time=( select max(login_time) from login_details);
End;
/


Testing:
--------

Step1: exit from the session

step2: login to ora8pm

step3: select * from login_details;

** how to calculate working hours

SQL>  select logout_time - login_time from login_details;

LOGOUT_TIME-LOGIN_TIME
---------------------------------------------------------------------------
+000000000 00:03:07.000000

** to see the created trigger names

   select object_name from user_objects where object_type='TRIGGER';

** to see the particular trigger body

   select text from user_source where name='HOLIDAY_TRIG';

** Drpping Triggers :
---------------------

  Drop trigger <trigger_name>;

Ex:-

  Drop Trigger my_trig;

PL/SQL Composite Datatypes :
----------------------------


BULK-COLLECT Clause :
---------------------

  -> It is used to copies db column values into pl/sql variables

  -> Pl/sql variables should be a pl/sql table type variables


Example :
---------

declare
  type names is table of emp.ename%type index by Binary_Integer;
  type Pays is table of emp.sal%type index by binary_Integer;
  N Names;
  P Pays;
Begin
    -- copying db column values into pl/sql table variables

 Select ename, sal Bulk collect into n, p from emp;

    -- displaying n,p arrays data

 for k in n.first..n.last
 loop
   dbms_output.put_Line( n(k)||' '||p(k) );
 end loop;
End;
/

SMITH 800
ALLEN 1600
WARD 1250
JONES 2975
MARTIN 1250
BLAKE 2850
CLARK 2450
KING 5000
TURNER 1500
ADAMS 1100
JAMES 950
FORD 3000
MILLER 1300

PL/SQL procedure successfully completed.



  
DECLARE	
 TYPE etype IS TABLE OF number(2);
 e etype  := etype(10,20,30,40);
 BEGIN
	/* PERFORM BULK DELETE OPERATION */
 	FORALL  i  IN  e.FIRST..e.LAST    -- 1..4
		DELETE FROM emp WHERE deptno = e(i);
	/* ROWS AFFECTED */	
	FOR i IN  e.FIRST..e.LAST   -- 1..4
  LOOP
    DBMS_OUTPUT.PUT_LINE(' Deptno = '||e(i)||'     '||'Rows affected = '||SQL%BULK_ROWCOUNT(i));
  END LOOP;
 END;

o/p:
Deptno = 10     Rows affected = 3
Deptno = 20     Rows affected = 4
Deptno = 30     Rows affected = 6
Deptno = 40     Rows affected = 0

PL/SQL procedure successfully completed.







  





   
















 
  













  



 
















 
















  













    
  





















